<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白IMao 的博客</title>
  
  
  <link href="https://robin5911.github.io/atom.xml" rel="self"/>
  
  <link href="https://robin5911.github.io/"/>
  <updated>2023-02-09T04:00:55.528Z</updated>
  <id>https://robin5911.github.io/</id>
  
  <author>
    <name>robin5911</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openstack-nova-虚机重启过程以及源码分析</title>
    <link href="https://robin5911.github.io/2023/02/09/openstack-nova-%E8%99%9A%E6%9C%BA%E9%87%8D%E5%90%AF%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://robin5911.github.io/2023/02/09/openstack-nova-%E8%99%9A%E6%9C%BA%E9%87%8D%E5%90%AF%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2023-02-09T03:43:34.000Z</published>
    <updated>2023-02-09T04:00:55.528Z</updated>
    
    <content type="html"><![CDATA[<h6 id="基于openstack-stein"><a href="#基于openstack-stein" class="headerlink" title="基于openstack stein"></a>基于openstack stein</h6><p>api收到重启请求后， _action_reboot 调用 compute_api 进行reboot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nova.api.openstack.compute.servers.ServersController</span><br><span class="line">def _action_reboot(self, req, id, body):</span><br><span class="line"></span><br><span class="line">        reboot_type &#x3D; body[&#39;reboot&#39;][&#39;type&#39;].upper()</span><br><span class="line">        context &#x3D; req.environ[&#39;nova.context&#39;]</span><br><span class="line">        context.can(server_policies.SERVERS % &#39;reboot&#39;)</span><br><span class="line">        instance &#x3D; self._get_server(context, req, id)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.compute_api.reboot(context, instance, reboot_type)</span><br><span class="line">            .................................................</span><br><span class="line">            </span><br><span class="line"> nova.compute.api.API</span><br><span class="line">  @check_instance_lock</span><br><span class="line">  def reboot(self, context, instance, reboot_type):</span><br><span class="line">        &quot;&quot;&quot;Reboot the given instance.&quot;&quot;&quot;</span><br><span class="line">        if reboot_type &#x3D;&#x3D; &#39;SOFT&#39;:</span><br><span class="line">            self._soft_reboot(context, instance)</span><br><span class="line">        else:</span><br><span class="line">            self._hard_reboot(context, instance)</span><br></pre></td></tr></table></figure><p>软重启和硬重启，将请求通过rpc 传给了nova compute</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nova.compute.manager.ComputeManager</span><br><span class="line">def reboot_instance(self, context, instance, block_device_info,</span><br><span class="line">                       reboot_type):</span><br><span class="line">       @utils.synchronized(instance.uuid)</span><br><span class="line">       def do_reboot_instance(context, instance, block_device_info,</span><br><span class="line">                              reboot_type):</span><br><span class="line">           self._reboot_instance(context, instance, block_device_info,</span><br><span class="line">                                 reboot_type)</span><br><span class="line">       do_reboot_instance(context, instance, block_device_info, reboot_type)</span><br></pre></td></tr></table></figure><p>变更虚机状态=&gt; 查询虚机block_device_map 信息=&gt;查询虚机network info, 最终调用libvirt 重启虚机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def _reboot_instance(self, context, instance, block_device_info,</span><br><span class="line">                         reboot_type):</span><br><span class="line">        &quot;&quot;&quot;Reboot an instance on this host.&quot;&quot;&quot;</span><br><span class="line">        # acknowledge the request made it to the manager</span><br><span class="line">        if reboot_type &#x3D;&#x3D; &quot;SOFT&quot;:</span><br><span class="line">            instance.task_state &#x3D; task_states.REBOOT_PENDING</span><br><span class="line">            expected_states &#x3D; task_states.soft_reboot_states</span><br><span class="line">        else:</span><br><span class="line">            instance.task_state &#x3D; task_states.REBOOT_PENDING_HARD</span><br><span class="line">            expected_states &#x3D; task_states.hard_reboot_states</span><br><span class="line"></span><br><span class="line">        context &#x3D; context.elevated()</span><br><span class="line">        LOG.info(&quot;Rebooting instance&quot;, instance&#x3D;instance)</span><br><span class="line"></span><br><span class="line">        bdms &#x3D; objects.BlockDeviceMappingList.get_by_instance_uuid(</span><br><span class="line">            context, instance.uuid)</span><br><span class="line">        block_device_info &#x3D; self._get_instance_block_device_info(</span><br><span class="line">            context, instance, bdms&#x3D;bdms)</span><br><span class="line"></span><br><span class="line">        network_info &#x3D; self.network_api.get_instance_nw_info(context, instance)</span><br><span class="line">       ........................................................................</span><br><span class="line">       self.driver.reboot(context, instance,</span><br><span class="line">                               network_info,</span><br><span class="line">                               reboot_type,</span><br><span class="line">                               block_device_info&#x3D;block_device_info,</span><br><span class="line">                               bad_volumes_callback&#x3D;bad_volumes_callback)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;基于openstack-stein&quot;&gt;&lt;a href=&quot;#基于openstack-stein&quot; class=&quot;headerlink&quot; title=&quot;基于openstack stein&quot;&gt;&lt;/a&gt;基于openstack stein&lt;/h6&gt;&lt;p&gt;api收到重启请求后， _action_reboot 调用 compute_api 进行reboot&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nova.api.openstack.compute.servers.ServersController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def _action_reboot(self, req, id, body):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reboot_type &amp;#x3D; body[&amp;#39;reboot&amp;#39;][&amp;#39;type&amp;#39;].upper()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        context &amp;#x3D; req.environ[&amp;#39;nova.context&amp;#39;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        context.can(server_policies.SERVERS % &amp;#39;reboot&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        instance &amp;#x3D; self._get_server(context, req, id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.compute_api.reboot(context, instance, reboot_type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .................................................&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; nova.compute.api.API&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @check_instance_lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def reboot(self, context, instance, reboot_type):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;Reboot the given instance.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if reboot_type &amp;#x3D;&amp;#x3D; &amp;#39;SOFT&amp;#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self._soft_reboot(context, instance)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self._hard_reboot(context, instance)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;软重启和硬重启，将请求通过rpc 传给了nova compute&lt;/p&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-cinder-虚机挂载云盘cinder侧过程以及源码分析</title>
    <link href="https://robin5911.github.io/2023/02/06/openstack-cinder-%E8%99%9A%E6%9C%BA%E6%8C%82%E8%BD%BD%E4%BA%91%E7%9B%98cinder%E4%BE%A7%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://robin5911.github.io/2023/02/06/openstack-cinder-%E8%99%9A%E6%9C%BA%E6%8C%82%E8%BD%BD%E4%BA%91%E7%9B%98cinder%E4%BE%A7%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2023-02-06T09:53:18.000Z</published>
    <updated>2023-02-06T09:59:31.312Z</updated>
    
    <content type="html"><![CDATA[<h6 id="本文基于openstack-Stein-版本"><a href="#本文基于openstack-Stein-版本" class="headerlink" title="本文基于openstack Stein 版本"></a>本文基于openstack Stein 版本</h6><p>上文分析nova挂载云盘过程中，提到调用cinder initialize_connection, 返回volume 的连接信息，比如rbd ceph 的connection info, 同时在 _parse_connection_options 中基于volume type 添加cinder io qos 信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cinder.volume.manager.VolumeManager.initialize_connection</span><br><span class="line">def initialize_connection(self, context, volume, connector):</span><br><span class="line">   ...............................................</span><br><span class="line">        try:</span><br><span class="line">            conn_info &#x3D; self.driver.initialize_connection(volume, connector)</span><br><span class="line">        except Exception as err:</span><br><span class="line">            err_msg &#x3D; (_(&quot;Driver initialize connection failed &quot;</span><br><span class="line">                         &quot;(error: %(err)s).&quot;) % &#123;&#39;err&#39;: six.text_type(err)&#125;)</span><br><span class="line">            LOG.exception(err_msg, resource&#x3D;volume)</span><br><span class="line"></span><br><span class="line">            self.driver.remove_export(context.elevated(), volume)</span><br><span class="line"></span><br><span class="line">            raise exception.VolumeBackendAPIException(data&#x3D;err_msg)</span><br><span class="line"></span><br><span class="line">        conn_info &#x3D; self._parse_connection_options(context, volume, conn_info)</span><br><span class="line">        LOG.info(&quot;Initialize volume connection completed successfully.&quot;,</span><br><span class="line">                 resource&#x3D;volume)</span><br><span class="line">        return conn_info</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def _parse_connection_options(self, context, volume, conn_info):</span><br><span class="line">       # Add qos_specs to connection info</span><br><span class="line">       typeid &#x3D; volume.volume_type_id</span><br><span class="line">       specs &#x3D; None</span><br><span class="line">       if typeid:</span><br><span class="line">           res &#x3D; volume_types.get_volume_type_qos_specs(typeid)</span><br><span class="line">           qos &#x3D; res[&#39;qos_specs&#39;]</span><br><span class="line">           # only pass qos_specs that is designated to be consumed by</span><br><span class="line">           # front-end, or both front-end and back-end.</span><br><span class="line">           if qos and qos.get(&#39;consumer&#39;) in [&#39;front-end&#39;, &#39;both&#39;]:</span><br><span class="line">               specs &#x3D; qos.get(&#39;specs&#39;)</span><br><span class="line"></span><br><span class="line">           # NOTE(mnaser): The following configures for per-GB QoS</span><br><span class="line">           if specs is not None:</span><br><span class="line">               volume_size &#x3D; int(volume.size)</span><br><span class="line">               tune_opts &#x3D; (&#39;read_iops_sec&#39;, &#39;read_bytes_sec&#39;,</span><br><span class="line">                            &#39;write_iops_sec&#39;, &#39;write_bytes_sec&#39;,</span><br><span class="line">                            &#39;total_iops_sec&#39;, &#39;total_bytes_sec&#39;)</span><br><span class="line"></span><br><span class="line">               for option in tune_opts:</span><br><span class="line">                   option_per_gb &#x3D; &#39;%s_per_gb&#39; % option</span><br><span class="line">                   option_per_gb_min &#x3D; &#39;%s_per_gb_min&#39; % option</span><br><span class="line">                   option_max &#x3D; &#39;%s_max&#39; % option</span><br><span class="line">                   option_base &#x3D; &#39;%s_base&#39; % option</span><br><span class="line">                   if option_per_gb in specs:</span><br><span class="line">                       minimum_value &#x3D; int(specs.pop(option_per_gb_min, 0))</span><br><span class="line">                       value &#x3D; int(specs[option_per_gb]) * volume_size</span><br><span class="line">                       per_gb_value &#x3D; max(minimum_value, value)</span><br><span class="line">                       base_value &#x3D; int(specs.pop(option_base, 0))</span><br><span class="line">                       final_value &#x3D; base_value + per_gb_value</span><br><span class="line">                       max_value &#x3D; int(specs.pop(option_max, final_value))</span><br><span class="line">                       specs[option] &#x3D; min(final_value, max_value)</span><br><span class="line">                       specs.pop(option_per_gb)</span><br><span class="line"></span><br><span class="line">       qos_spec &#x3D; dict(qos_specs&#x3D;specs)</span><br><span class="line">       conn_info[&#39;data&#39;].update(qos_spec)</span><br><span class="line">       ...............................................</span><br></pre></td></tr></table></figure><p>connection info 返回给了nova，nova侧使用即可，至于attachment 只是数据库里面变更一下记录而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;本文基于openstack-Stein-版本&quot;&gt;&lt;a href=&quot;#本文基于openstack-Stein-版本&quot; class=&quot;headerlink&quot; title=&quot;本文基于openstack Stein 版本&quot;&gt;&lt;/a&gt;本文基于openstack Stein </summary>
      
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-nova-虚机挂载云盘过程以及源码分析</title>
    <link href="https://robin5911.github.io/2023/02/06/openstack-nova-%E8%99%9A%E6%9C%BA%E6%8C%82%E8%BD%BD%E4%BA%91%E7%9B%98%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://robin5911.github.io/2023/02/06/openstack-nova-%E8%99%9A%E6%9C%BA%E6%8C%82%E8%BD%BD%E4%BA%91%E7%9B%98%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2023-02-06T08:36:46.000Z</published>
    <updated>2023-02-08T03:08:32.578Z</updated>
    
    <content type="html"><![CDATA[<h6 id="本文基于openstack-Stein-版本"><a href="#本文基于openstack-Stein-版本" class="headerlink" title="本文基于openstack Stein 版本"></a>本文基于openstack Stein 版本</h6><p>nova 侧虚机需要挂载云盘，包括创建时挂载系统盘以及普通数据盘</p><p>代码在 nova\compute]manager.py, nova 获取volume信息，并发起attach请求，最终调用cinder api发起了attach请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nova.compute.manager.ComputeManager._attach_volume:</span><br><span class="line">    try:</span><br><span class="line">            bdm.attach(context, instance, self.volume_api, self.driver,</span><br><span class="line">                       do_driver_attach&#x3D;True)</span><br><span class="line">    ......................................</span><br><span class="line">    </span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nova.virt.block_device.DriverVolumeBlockDevice.attach</span><br><span class="line">def attach(self, context, instance, volume_api, virt_driver,</span><br><span class="line">               do_driver_attach&#x3D;False, **kwargs):</span><br><span class="line">     ...................................</span><br><span class="line">            self._do_attach(context, instance, volume, volume_api,</span><br><span class="line">                            virt_driver, do_driver_attach)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nova.virt.block_device.DriverVolumeBlockDevice.attach_volume</span><br><span class="line">def _do_attach(self, context, instance, volume, volume_api, virt_driver,</span><br><span class="line">                   do_driver_attach):</span><br><span class="line">      ...................</span><br><span class="line">            self._legacy_volume_attach(context, volume, connector, instance,</span><br><span class="line">      ..........................</span><br></pre></td></tr></table></figure><p>这里没有attachment id调用了_legacy_volume_attach</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">nova.virt.block_device.DriverVolumeBlockDevice._legacy_volume_attach</span><br><span class="line">def _legacy_volume_attach(self, context, volume, connector, instance,</span><br><span class="line">                              volume_api, virt_driver,</span><br><span class="line">                              do_driver_attach&#x3D;False):</span><br><span class="line">        volume_id &#x3D; volume[&#39;id&#39;]</span><br><span class="line"></span><br><span class="line">        connection_info &#x3D; volume_api.initialize_connection(context,</span><br><span class="line">                                                           volume_id,</span><br><span class="line">                                                           connector)  #调用cinder client初始化connection连接信息</span><br><span class="line">       .....................................................................</span><br><span class="line">            try:</span><br><span class="line">                virt_driver.attach_volume(</span><br><span class="line">                        context, connection_info, instance,</span><br><span class="line">                        self[&#39;mount_device&#39;], disk_bus&#x3D;self[&#39;disk_bus&#39;],</span><br><span class="line">                        device_type&#x3D;self[&#39;device_type&#39;], encryption&#x3D;encryption)  #调用libvirt 连接volume云盘</span><br><span class="line">            except Exception:</span><br><span class="line">                with excutils.save_and_reraise_exception():</span><br><span class="line">                    LOG.exception(&quot;Driver failed to attach volume &quot;</span><br><span class="line">                                  &quot;%(volume_id)s at %(mountpoint)s&quot;,</span><br><span class="line">                                  &#123;&#39;volume_id&#39;: volume_id,</span><br><span class="line">                                   &#39;mountpoint&#39;: self[&#39;mount_device&#39;]&#125;,</span><br><span class="line">                                  instance&#x3D;instance)</span><br><span class="line">                    volume_api.terminate_connection(context, volume_id,</span><br><span class="line">                                                    connector)</span><br><span class="line">        self[&#39;connection_info&#39;] &#x3D; connection_info</span><br><span class="line">        if self.volume_size is None:</span><br><span class="line">            self.volume_size &#x3D; volume.get(&#39;size&#39;)</span><br><span class="line"></span><br><span class="line">        mode &#x3D; &#39;rw&#39;</span><br><span class="line">        if &#39;data&#39; in connection_info:</span><br><span class="line">            mode &#x3D; connection_info[&#39;data&#39;].get(&#39;access_mode&#39;, &#39;rw&#39;)</span><br><span class="line">        if volume[&#39;attach_status&#39;] &#x3D;&#x3D; &quot;detached&quot;:</span><br><span class="line">            # NOTE(mriedem): save our current state so connection_info is in</span><br><span class="line">            # the database before the volume status goes to &#39;in-use&#39; because</span><br><span class="line">            # after that we can detach and connection_info is required for</span><br><span class="line">            # detach.</span><br><span class="line">            self.save()</span><br><span class="line">            try:</span><br><span class="line">                volume_api.attach(context, volume_id, instance.uuid,</span><br><span class="line">                                  self[&#39;mount_device&#39;], mode&#x3D;mode)    #挂载云盘</span><br><span class="line">        ...................................</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">nova.libvirt.driver.ComputeDriver.attach_volume</span><br><span class="line">    def attach_volume(self, context, connection_info, instance, mountpoint,</span><br><span class="line">                      disk_bus&#x3D;None, device_type&#x3D;None, encryption&#x3D;None):</span><br><span class="line">        guest &#x3D; self._host.get_guest(instance)</span><br><span class="line"></span><br><span class="line">        disk_dev &#x3D; mountpoint.rpartition(&quot;&#x2F;&quot;)[2]</span><br><span class="line">        bdm &#x3D; &#123;</span><br><span class="line">            &#39;device_name&#39;: disk_dev,</span><br><span class="line">            &#39;disk_bus&#39;: disk_bus,</span><br><span class="line">            &#39;device_type&#39;: device_type&#125;</span><br><span class="line"></span><br><span class="line">        # Note(cfb): If the volume has a custom block size, check that</span><br><span class="line">        #            that we are using QEMU&#x2F;KVM and libvirt &gt;&#x3D; 0.10.2. The</span><br><span class="line">        #            presence of a block size is considered mandatory by</span><br><span class="line">        #            cinder so we fail if we can&#39;t honor the request.</span><br><span class="line">        data &#x3D; &#123;&#125;</span><br><span class="line">        if (&#39;data&#39; in connection_info):</span><br><span class="line">            data &#x3D; connection_info[&#39;data&#39;]</span><br><span class="line">        if (&#39;logical_block_size&#39; in data or &#39;physical_block_size&#39; in data):</span><br><span class="line">            if ((CONF.libvirt.virt_type !&#x3D; &quot;kvm&quot; and</span><br><span class="line">                 CONF.libvirt.virt_type !&#x3D; &quot;qemu&quot;)):</span><br><span class="line">                msg &#x3D; _(&quot;Volume sets block size, but the current &quot;</span><br><span class="line">                        &quot;libvirt hypervisor &#39;%s&#39; does not support custom &quot;</span><br><span class="line">                        &quot;block size&quot;) % CONF.libvirt.virt_type</span><br><span class="line">                raise exception.InvalidHypervisorType(msg)</span><br><span class="line"></span><br><span class="line">        self._connect_volume(context, connection_info, instance,</span><br><span class="line">                             encryption&#x3D;encryption)</span><br></pre></td></tr></table></figure><p>上面从nova收到请求，到调用cinder client 挂载云盘，再到libvirt 连接volume，从而虚机可以识别到磁盘，至此完成！</p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;本文基于openstack-Stein-版本&quot;&gt;&lt;a href=&quot;#本文基于openstack-Stein-版本&quot; class=&quot;headerlink&quot; title=&quot;本文基于openstack Stein 版本&quot;&gt;&lt;/a&gt;本文基于openstack Stein 版本&lt;/h6&gt;&lt;p&gt;nova 侧虚机需要挂载云盘，包括创建时挂载系统盘以及普通数据盘&lt;/p&gt;
&lt;p&gt;代码在 nova\compute]manager.py, nova 获取volume信息，并发起attach请求，最终调用cinder api发起了attach请求。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nova.compute.manager.ComputeManager._attach_volume:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bdm.attach(context, instance, self.volume_api, self.driver,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       do_driver_attach&amp;#x3D;True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......................................&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack cinder volume创建流程以及源码分析(三)</title>
    <link href="https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/"/>
    <id>https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/</id>
    <published>2023-02-03T08:04:06.000Z</published>
    <updated>2023-02-08T01:45:23.684Z</updated>
    
    <content type="html"><![CDATA[<h6 id="本文基于openstack-Stein-版本"><a href="#本文基于openstack-Stein-版本" class="headerlink" title="本文基于openstack Stein 版本"></a>本文基于openstack Stein 版本</h6><p>上文中，volume创建经scheduler 已经rpc  cast 传给了 volume.</p><p>(1) cinder\volume\manager.py<br>VolumeManager.create_volume 函数对创建请求进行响应，并调用cinder.volume.flows.api.get_flow来创建。。</p><p>OnFailureReschedulerTask 当scheduer失败时重试，ExtractVolumeSpecTask 获取volume创建spec内容，NotifyVolumeActionTask 通知volume 创建动作，最终开始干活 CreateVolumeFromSpecTask 创建volume，以及 CreateVolumeOnFinishTask 通知volume创建完成。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cinder.volume.manager.VolumeManager.create_volume</span><br><span class="line">   try:</span><br><span class="line">           # NOTE(flaper87): Driver initialization is</span><br><span class="line">           # verified by the task itself.</span><br><span class="line">           flow_engine &#x3D; create_volume.get_flow(</span><br><span class="line">               context_elevated,</span><br><span class="line">               self,</span><br><span class="line">               self.db,</span><br><span class="line">               self.driver,</span><br><span class="line">               self.scheduler_rpcapi,</span><br><span class="line">               self.host,</span><br><span class="line">               volume,</span><br><span class="line">               allow_reschedule,</span><br><span class="line">               context,</span><br><span class="line">               request_spec,</span><br><span class="line">               filter_properties,</span><br><span class="line">               image_volume_cache&#x3D;self.image_volume_cache,</span><br><span class="line">           )</span><br><span class="line">       except Exception:</span><br><span class="line">           msg &#x3D; _(&quot;Create manager volume flow failed.&quot;)</span><br><span class="line">           LOG.exception(msg, resource&#x3D;&#123;&#39;type&#39;: &#39;volume&#39;, &#39;id&#39;: volume.id&#125;)</span><br><span class="line">           raise exception.CinderException(msg)</span><br></pre></td></tr></table></figure><p> CreateVolumeFromSpecTask  中又根据创建类型，是普通volume，还是image，还是备份还是快照等动作会有区别，这里已使用ceph的image创建为例，最终调用rbd的 _clone 函数clone 出一个块设备，最终resize 一下大小，同时更新根据image 元数据更新volume相关信息，最终更新volume 数据库相关信息。</p><p>CreateVolumeOnFinishTask 当volume创建完之后，更新volume 数据库状态信息。</p><p>支持volume 已经创建完成！</p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;本文基于openstack-Stein-版本&quot;&gt;&lt;a href=&quot;#本文基于openstack-Stein-版本&quot; class=&quot;headerlink&quot; title=&quot;本文基于openstack Stein 版本&quot;&gt;&lt;/a&gt;本文基于openstack Stein 版本&lt;/h6&gt;&lt;p&gt;上文中，volume创建经scheduler 已经rpc  cast 传给了 volume.&lt;/p&gt;
&lt;p&gt;(1) cinder\volume\manager.py&lt;br&gt;VolumeManager.create_volume 函数对创建请求进行响应，并调用cinder.volume.flows.api.get_flow来创建。。&lt;/p&gt;
&lt;p&gt;OnFailureReschedulerTask 当scheduer失败时重试，ExtractVolumeSpecTask 获取volume创建spec内容，NotifyVolumeActionTask 通知volume 创建动作，最终开始干活 CreateVolumeFromSpecTask 创建volume，以及 CreateVolumeOnFinishTask 通知volume创建完成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack cinder volume创建流程以及源码分析(二)</title>
    <link href="https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/"/>
    <id>https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/</id>
    <published>2023-02-03T08:03:58.000Z</published>
    <updated>2023-02-08T01:45:15.885Z</updated>
    
    <content type="html"><![CDATA[<h6 id="本文基于openstack-Stein-版本"><a href="#本文基于openstack-Stein-版本" class="headerlink" title="本文基于openstack Stein 版本"></a>本文基于openstack Stein 版本</h6><p>上文中，volume创建经api已经rpc  cast 传给了 scheduler.</p><p>(1) cinder\scheduler\manager.py<br>SchedulerManager.create_volume 函数对创建请求进行响应，并调用cinder.scheduler.flows.api.get_flow来创建。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cinder.scheduler.manager.SchedulerManager.create_volume</span><br><span class="line">        try:</span><br><span class="line">            flow_engine &#x3D; create_volume.get_flow(context,</span><br><span class="line">                                                 self.driver,</span><br><span class="line">                                                 request_spec,</span><br><span class="line">                                                 filter_properties,</span><br><span class="line">                                                 volume,</span><br><span class="line">                                                 snapshot_id,</span><br><span class="line">                                                 image_id,</span><br><span class="line">                                                 backup_id)</span><br><span class="line">        except Exception:</span><br><span class="line">            msg &#x3D; _(&quot;Failed to create scheduler manager volume flow&quot;)</span><br><span class="line">            LOG.exception(msg)</span><br><span class="line">            raise exception.CinderException(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><p>(2) cinder\scheduler\flows\api\create_volume.py<br>get_flow函数先执行 ExtractSchedulerSpecTask 任务获取请求信息，再调用 ScheduleCreateVolumeTask  调度volume。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cinder.scheduler.flows.create_volume.ScheduleCreateVolumeTask.execute:</span><br><span class="line">        try:</span><br><span class="line">            if CONF.enable_multi_ceph:</span><br><span class="line">                get_remote_image_service &#x3D; glance.get_remote_image_service</span><br><span class="line">                image_href &#x3D; request_spec.get(&#39;image_id&#39;)</span><br><span class="line">                if image_href:</span><br><span class="line">                    image_service, image_id &#x3D; get_remote_image_service(context,</span><br><span class="line">                                                                   image_href)</span><br><span class="line">                    image_location &#x3D; image_service.get_location(context,</span><br><span class="line">                                                                image_id)</span><br><span class="line">                    filter_properties[&#39;image_location&#39;] &#x3D; image_location</span><br><span class="line">            self.driver_api.schedule_create_volume(context, request_spec,</span><br><span class="line">                                                   filter_properties)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.message_api.create(</span><br><span class="line">                context,</span><br><span class="line">                message_field.Action.SCHEDULE_ALLOCATE_VOLUME,</span><br><span class="line">                resource_uuid&#x3D;request_spec[&#39;volume_id&#39;],</span><br><span class="line">                exception&#x3D;e)</span><br><span class="line">            # An error happened, notify on the scheduler queue and log that</span><br><span class="line">            # this happened and set the volume to errored out and reraise the</span><br><span class="line">            # error *if* exception caught isn&#39;t NoValidBackend. Otherwise *do</span><br><span class="line">            # not* reraise (since what&#39;s the point?)</span><br><span class="line">            with excutils.save_and_reraise_exception(</span><br><span class="line">                    reraise&#x3D;not isinstance(e, exception.NoValidBackend)):</span><br><span class="line">                try:</span><br><span class="line">                    self._handle_failure(context, request_spec, e)</span><br><span class="line">                finally:</span><br><span class="line">                    common.error_out(volume, reason&#x3D;e)</span><br></pre></td></tr></table></figure><p>(3) cinder\scheduler\filter_scheduler.py</p><p>FilterScheduler. schedule_create_volume 函数对创建请求调度选出backend，如果没有合适的backend则抛异常报no weighed backend,  调用 _get_weighted_candidates 从 cinder service中根据scheduler的filter选出合适的backends，再调用 get_weighed_backends 选出最优的backends， 最终调用volume rpc 来创建volume。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">cinder.scheduler.filter_scheduler.FilterScheduler.schedule_create_volume:</span><br><span class="line">   def _get_weighted_candidates(self, context, request_spec,</span><br><span class="line">                                 filter_properties&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;Return a list of backends that meet required specs.</span><br><span class="line"></span><br><span class="line">        Returned list is ordered by their fitness.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        elevated &#x3D; context.elevated()</span><br><span class="line"></span><br><span class="line">        # Since Cinder is using mixed filters from Oslo and it&#39;s own, which</span><br><span class="line">        # takes &#39;resource_XX&#39; and &#39;volume_XX&#39; as input respectively, copying</span><br><span class="line">        # &#39;volume_XX&#39; to &#39;resource_XX&#39; will make both filters happy.</span><br><span class="line">        volume_type &#x3D; request_spec.get(&quot;volume_type&quot;)</span><br><span class="line">        resource_type &#x3D; volume_type if volume_type is not None else &#123;&#125;</span><br><span class="line"></span><br><span class="line">        config_options &#x3D; self._get_configuration_options()</span><br><span class="line"></span><br><span class="line">        if filter_properties is None:</span><br><span class="line">            filter_properties &#x3D; &#123;&#125;</span><br><span class="line">        self._populate_retry(filter_properties,</span><br><span class="line">                             request_spec)</span><br><span class="line"></span><br><span class="line">        request_spec_dict &#x3D; jsonutils.to_primitive(request_spec)</span><br><span class="line"></span><br><span class="line">        filter_properties.update(&#123;&#39;context&#39;: context,</span><br><span class="line">                                  &#39;request_spec&#39;: request_spec_dict,</span><br><span class="line">                                  &#39;config_options&#39;: config_options,</span><br><span class="line">                                  &#39;volume_type&#39;: volume_type,</span><br><span class="line">                                  &#39;resource_type&#39;: resource_type&#125;)</span><br><span class="line"></span><br><span class="line">        self.populate_filter_properties(request_spec,</span><br><span class="line">                                        filter_properties)</span><br><span class="line"></span><br><span class="line">        # If multiattach is enabled on a volume, we need to add</span><br><span class="line">        # multiattach to extra specs, so that the capability</span><br><span class="line">        # filtering is enabled.</span><br><span class="line">        multiattach &#x3D; request_spec[&#39;volume_properties&#39;].get(&#39;multiattach&#39;,</span><br><span class="line">                                                            False)</span><br><span class="line">        if multiattach and &#39;multiattach&#39; not in resource_type.get(</span><br><span class="line">                &#39;extra_specs&#39;, &#123;&#125;):</span><br><span class="line">            if &#39;extra_specs&#39; not in resource_type:</span><br><span class="line">                resource_type[&#39;extra_specs&#39;] &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">            resource_type[&#39;extra_specs&#39;].update(</span><br><span class="line">                multiattach&#x3D;&#39;&lt;is&gt; True&#39;)</span><br><span class="line"></span><br><span class="line">        # Revert volume consumed capacity if it&#39;s a rescheduled request</span><br><span class="line">        retry &#x3D; filter_properties.get(&#39;retry&#39;, &#123;&#125;)</span><br><span class="line">        if retry.get(&#39;backends&#39;, []):</span><br><span class="line">            self.host_manager.revert_volume_consumed_capacity(</span><br><span class="line">                retry[&#39;backends&#39;][-1],</span><br><span class="line">                request_spec[&#39;volume_properties&#39;][&#39;size&#39;])</span><br><span class="line">        # Find our local list of acceptable backends by filtering and</span><br><span class="line">        # weighing our options. we virtually consume resources on</span><br><span class="line">        # it so subsequent selections can adjust accordingly.</span><br><span class="line"></span><br><span class="line">        # Note: remember, we are using an iterator here. So only</span><br><span class="line">        # traverse this list once.</span><br><span class="line">        backends &#x3D; self.host_manager.get_all_backend_states(elevated)</span><br><span class="line"></span><br><span class="line">        # Filter local hosts based on requirements ...</span><br><span class="line">        backends &#x3D; self.host_manager.get_filtered_backends(backends,</span><br><span class="line">                                                           filter_properties)</span><br><span class="line">        if not backends:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        LOG.debug(&quot;Filtered %s&quot;, backends)</span><br><span class="line">        # weighted_backends &#x3D; WeightedHost() ... the best</span><br><span class="line">        # backend for the job.</span><br><span class="line">        weighed_backends &#x3D; self.host_manager.get_weighed_backends(</span><br><span class="line">            backends, filter_properties)</span><br><span class="line">        return weighed_backends</span><br><span class="line">    def _schedule(self, context, request_spec, filter_properties&#x3D;None):</span><br><span class="line">        weighed_backends &#x3D; self._get_weighted_candidates(context, request_spec,</span><br><span class="line">                                                         filter_properties)</span><br><span class="line">        # When we get the weighed_backends, we clear those backends that don&#39;t</span><br><span class="line">        # match the resource&#39;s backend (it could be assigend from group,</span><br><span class="line">        # snapshot or volume).</span><br><span class="line">        resource_backend &#x3D; request_spec.get(&#39;resource_backend&#39;)</span><br><span class="line">        if weighed_backends and resource_backend:</span><br><span class="line">            resource_backend_has_pool &#x3D; bool(utils.extract_host(</span><br><span class="line">                resource_backend, &#39;pool&#39;))</span><br><span class="line">            # Get host name including host@backend#pool info from</span><br><span class="line">            # weighed_backends.</span><br><span class="line">            for backend in weighed_backends[::-1]:</span><br><span class="line">                backend_id &#x3D; (</span><br><span class="line">                    backend.obj.backend_id if resource_backend_has_pool</span><br><span class="line">                    else utils.extract_host(backend.obj.backend_id)</span><br><span class="line">                )</span><br><span class="line">                if backend_id !&#x3D; resource_backend:</span><br><span class="line">                    weighed_backends.remove(backend)</span><br><span class="line">        if not weighed_backends:</span><br><span class="line">            LOG.warning(&#39;No weighed backend found for volume &#39;</span><br><span class="line">                        &#39;with properties: %s&#39;,</span><br><span class="line">                        filter_properties[&#39;request_spec&#39;].get(&#39;volume_type&#39;))</span><br><span class="line">            return None</span><br><span class="line">        return self._choose_top_backend(weighed_backends, request_spec)</span><br><span class="line">   def schedule_create_volume(self, context, request_spec, filter_properties):</span><br><span class="line">        backend &#x3D; self._schedule(context, request_spec, filter_properties)</span><br><span class="line"></span><br><span class="line">        if not backend:</span><br><span class="line">            raise exception.NoValidBackend(reason&#x3D;_(&quot;No weighed backends &quot;</span><br><span class="line">                                                    &quot;available&quot;))</span><br><span class="line"></span><br><span class="line">        backend &#x3D; backend.obj</span><br><span class="line">        volume_id &#x3D; request_spec[&#39;volume_id&#39;]</span><br><span class="line"></span><br><span class="line">        updated_volume &#x3D; driver.volume_update_db(</span><br><span class="line">            context, volume_id,</span><br><span class="line">            backend.host,</span><br><span class="line">            backend.cluster_name,</span><br><span class="line">            availability_zone&#x3D;backend.service[&#39;availability_zone&#39;])</span><br><span class="line">        self._post_select_populate_filter_properties(filter_properties,</span><br><span class="line">                                                     backend)</span><br><span class="line"></span><br><span class="line">        # context is not serializable</span><br><span class="line">        filter_properties.pop(&#39;context&#39;, None)</span><br><span class="line"></span><br><span class="line">        self.volume_rpcapi.create_volume(context, updated_volume, request_spec,</span><br><span class="line">                                         filter_properties,</span><br><span class="line">                                         allow_reschedule&#x3D;True)     </span><br></pre></td></tr></table></figure><p>至此，scheduler侧的任务已经完成！</p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;本文基于openstack-Stein-版本&quot;&gt;&lt;a href=&quot;#本文基于openstack-Stein-版本&quot; class=&quot;headerlink&quot; title=&quot;本文基于openstack Stein 版本&quot;&gt;&lt;/a&gt;本文基于openstack Stein 版本&lt;/h6&gt;&lt;p&gt;上文中，volume创建经api已经rpc  cast 传给了 scheduler.&lt;/p&gt;
&lt;p&gt;(1) cinder\scheduler\manager.py&lt;br&gt;SchedulerManager.create_volume 函数对创建请求进行响应，并调用cinder.scheduler.flows.api.get_flow来创建。。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cinder.scheduler.manager.SchedulerManager.create_volume&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            flow_engine &amp;#x3D; create_volume.get_flow(context,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 self.driver,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 request_spec,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 filter_properties,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 volume,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 snapshot_id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 image_id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 backup_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        except Exception:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            msg &amp;#x3D; _(&amp;quot;Failed to create scheduler manager volume flow&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LOG.exception(msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            raise exception.CinderException(msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack cinder volume创建流程以及源码分析(一)</title>
    <link href="https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80/"/>
    <id>https://robin5911.github.io/2023/02/03/openstack-cinder-volume%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80/</id>
    <published>2023-02-03T07:44:38.000Z</published>
    <updated>2023-02-08T01:45:26.583Z</updated>
    
    <content type="html"><![CDATA[<h6 id="本文基于openstack-Stein-版本"><a href="#本文基于openstack-Stein-版本" class="headerlink" title="本文基于openstack Stein 版本"></a>本文基于openstack Stein 版本</h6><h4 id="1-cinder-创建整体流程"><a href="#1-cinder-创建整体流程" class="headerlink" title="1. cinder 创建整体流程"></a>1. cinder 创建整体流程</h4><p><img src="/images/openstack/71de5178-d61e-11e5-8d7c-6b9f0a244e41.png"></p><p>如整体架构图所示，创建卷涉及的答题步骤主要有以下几步：<br>a. Client发送请求，通过RESTFUL接口访问cinder-api。<br>b. Api解析响应请求，api解析由Client发送来的请求，并通过rpc进一步调用cinder-scheduler。<br>c. Scheduler对资源进行调度，scheduler选择合适的节点进行。<br>d. Volume调用Driver创建卷，volume通过指定Driver进行卷的创建。</p><h4 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h4><a id="more"></a><p>(1) cinder\api\v3\volumes.py<br>VolumeController. create函数对创建请求进行响应，首先函数对name, size，volume_type、metadata、snapshot等信息进行获取，然后调用Volume API的create进行创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cinder.api.v3.volumes.VolumeController.create:</span><br><span class="line">    # 对name,size,volume_type、metadata、snapshot等信息进行获取</span><br><span class="line">    new_volume &#x3D; self.volume_api.create(context,</span><br><span class="line">                                            size,</span><br><span class="line">                                            volume.get(&#39;display_name&#39;),</span><br><span class="line">                                            volume.get(&#39;display_description&#39;),</span><br><span class="line">                                            **kwargs)</span><br></pre></td></tr></table></figure><p>(2) cinder\volume\api.py<br>API.create函数对source_volume、volume_type等参数进行进一步检查，确保无误，并调用cinder.volume.flows.api.get_flow来创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cinder.volume.api.API.create:</span><br><span class="line">     try:</span><br><span class="line">            sched_rpcapi &#x3D; (self.scheduler_rpcapi if (</span><br><span class="line">                            not cgsnapshot and not source_cg and</span><br><span class="line">                            not group_snapshot and not source_group)</span><br><span class="line">                            else None)</span><br><span class="line">            volume_rpcapi &#x3D; (self.volume_rpcapi if (</span><br><span class="line">                             not cgsnapshot and not source_cg and</span><br><span class="line">                             not group_snapshot and not source_group)</span><br><span class="line">                             else None)</span><br><span class="line">            flow_engine &#x3D; create_volume.get_flow(self.db,</span><br><span class="line">                                                 self.image_service,</span><br><span class="line">                                                 availability_zones,</span><br><span class="line">                                                 create_what,</span><br><span class="line">                                                 sched_rpcapi,</span><br><span class="line">                                                 volume_rpcapi)</span><br><span class="line">        except Exception:</span><br><span class="line">            msg &#x3D; _(&#39;Failed to create api volume flow.&#39;)</span><br><span class="line">            LOG.exception(msg)</span><br><span class="line">            raise exception.CinderException(msg)</span><br></pre></td></tr></table></figure><p>(3) cinder\volume\flows\api\create_volume.py<br>get_flow函数检查Quata配额，最后创建EntryCreateTask及VolumeCastTask等任务，<br>其中EntryCreateTask会将卷的创建过程写入数据库，此时卷的状态为”creating”。<br>VolumeCastTask.excute函数会调用VoumeCastTask._cast_create_volume<br>VolumeCastTask._cast_create_volume函数，如果未传入host，则会经过调度进行创建卷，通过scheduler_rpcapi.create_volume创建卷；如果未传入host则直接交由Volume Manager去创建卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cinder.volume.flows.api.create_volume.VolumeCastTask._cast_create_volume:</span><br><span class="line">  self.scheduler_rpcapi.create_volume(</span><br><span class="line">            context,</span><br><span class="line">            volume,</span><br><span class="line">            snapshot_id&#x3D;snapshot_id,</span><br><span class="line">            image_id&#x3D;image_id,</span><br><span class="line">            request_spec&#x3D;request_spec,</span><br><span class="line">            filter_properties&#x3D;filter_properties,</span><br><span class="line">            backup_id&#x3D;backup_id)</span><br></pre></td></tr></table></figure><p>至此为止，Cinder API部分完成了自己的工作。</p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;本文基于openstack-Stein-版本&quot;&gt;&lt;a href=&quot;#本文基于openstack-Stein-版本&quot; class=&quot;headerlink&quot; title=&quot;本文基于openstack Stein 版本&quot;&gt;&lt;/a&gt;本文基于openstack Stein 版本&lt;/h6&gt;&lt;h4 id=&quot;1-cinder-创建整体流程&quot;&gt;&lt;a href=&quot;#1-cinder-创建整体流程&quot; class=&quot;headerlink&quot; title=&quot;1. cinder 创建整体流程&quot;&gt;&lt;/a&gt;1. cinder 创建整体流程&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/openstack/71de5178-d61e-11e5-8d7c-6b9f0a244e41.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如整体架构图所示，创建卷涉及的答题步骤主要有以下几步：&lt;br&gt;a. Client发送请求，通过RESTFUL接口访问cinder-api。&lt;br&gt;b. Api解析响应请求，api解析由Client发送来的请求，并通过rpc进一步调用cinder-scheduler。&lt;br&gt;c. Scheduler对资源进行调度，scheduler选择合适的节点进行。&lt;br&gt;d. Volume调用Driver创建卷，volume通过指定Driver进行卷的创建。&lt;/p&gt;
&lt;h4 id=&quot;2-源码详解&quot;&gt;&lt;a href=&quot;#2-源码详解&quot; class=&quot;headerlink&quot; title=&quot;2. 源码详解&quot;&gt;&lt;/a&gt;2. 源码详解&lt;/h4&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化-ovs-常用命令集合</title>
    <link href="https://robin5911.github.io/2023/01/17/%E8%99%9A%E6%8B%9F%E5%8C%96-ovs-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <id>https://robin5911.github.io/2023/01/17/%E8%99%9A%E6%8B%9F%E5%8C%96-ovs-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</id>
    <published>2023-01-17T02:30:24.000Z</published>
    <updated>2023-02-15T07:40:11.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="整理常用的ovs命令集合"><a href="#整理常用的ovs命令集合" class="headerlink" title="整理常用的ovs命令集合"></a>整理常用的ovs命令集合</h4><h6 id="基于Openvswitch-2-11"><a href="#基于Openvswitch-2-11" class="headerlink" title="基于Openvswitch 2.11"></a>基于Openvswitch 2.11</h6><h6 id="ovs-vsctl"><a href="#ovs-vsctl" class="headerlink" title="ovs-vsctl"></a>ovs-vsctl</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">显示主机已有网桥以及端口port信息,以及vxlan隧道信息</span><br><span class="line">#ovs-vsctl show</span><br><span class="line"></span><br><span class="line">添加网桥</span><br><span class="line">#ovs-vsctl add-br br-test</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ovs-ofctl"><a href="#ovs-ofctl" class="headerlink" title="ovs-ofctl"></a>ovs-ofctl</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出交换机信息，输出交换机上的网卡以及端口port信息</span><br><span class="line">#ovs-ofctl show br-int</span><br><span class="line"></span><br><span class="line">输出交换机的端口统计信息，包括收发包、丢包、错误包等数量</span><br><span class="line">#ovs-ofctl dump-ports br-int -O openFlow13</span><br><span class="line"></span><br><span class="line">查看交换机流表信息</span><br><span class="line">#ovs-ofctl dump-flows br-int</span><br><span class="line"></span><br><span class="line">添加交换机流表</span><br><span class="line">#ovs-ofctl add-flow br-int ********</span><br></pre></td></tr></table></figure><h6 id="ovs-dpctl"><a href="#ovs-dpctl" class="headerlink" title="ovs-dpctl"></a>ovs-dpctl</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">显示所有datapath基本信息</span><br><span class="line">#ovs-dpctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ovs-appctl"><a href="#ovs-appctl" class="headerlink" title="ovs-appctl"></a>ovs-appctl</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询虚机mac fa:16:3e:ac:21:48 到 虚机 fa:16:3e:b0:bf:cc的流表trace路径</span><br><span class="line">#ovs-appctl ofproto&#x2F;trace br-int in_port&#x3D;27,dl_src&#x3D;fa:16:3e:ac:21:48,dl_dst&#x3D;fa:16:3e:b0:bf:cc</span><br></pre></td></tr></table></figure><h6 id="例-查询虚机-test01-宿主机-hyper123-到虚机-test02-宿主机hyper09-的路径"><a href="#例-查询虚机-test01-宿主机-hyper123-到虚机-test02-宿主机hyper09-的路径" class="headerlink" title="例 :  查询虚机 test01 (宿主机 hyper123) 到虚机 test02(宿主机hyper09)的路径"></a>例 :  查询虚机 test01 (宿主机 hyper123) 到虚机 test02(宿主机hyper09)的路径</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 查询虚机test01 (tapa6df2bfb-e5)的 port id以及mac </span><br><span class="line">   #ovs-ofctl show br-int -O openFlow13|grep tapa6df2bfb-e5  #查出是8号，mac     fa:16:3e:f6:b8:81</span><br><span class="line">2. 查询虚机test02 (tapf9689b0e-e4)的 port id</span><br><span class="line">   #ovs-ofctl show br-int -O openFlow13|grep tapf9689b0e-e4  查出是13号，mac是fa:16:3e:5a:35:74</span><br><span class="line">3. 查询虚机test01到test02的icmp流表路径</span><br><span class="line">#docker exec -it -uroot openvswitch_vswitchd bash</span><br><span class="line">#ovs-appctl ofproto&#x2F;trace br-int in_port&#x3D;8,dl_src&#x3D;fa:16:3e:f6:b8:81,dl_dst&#x3D;fa:16:3e:5a:35:74</span><br><span class="line"></span><br><span class="line">如果能在br-tun上送到 kernel tunnel代表正常</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;整理常用的ovs命令集合&quot;&gt;&lt;a href=&quot;#整理常用的ovs命令集合&quot; class=&quot;headerlink&quot; title=&quot;整理常用的ovs命令集合&quot;&gt;&lt;/a&gt;整理常用的ovs命令集合&lt;/h4&gt;&lt;h6 id=&quot;基于Openvswitch-2-11&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="ovs" scheme="https://robin5911.github.io/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化-ovs-学习(1)</title>
    <link href="https://robin5911.github.io/2023/01/16/%E8%99%9A%E6%8B%9F%E5%8C%96-ovs-%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://robin5911.github.io/2023/01/16/%E8%99%9A%E6%8B%9F%E5%8C%96-ovs-%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2023-01-16T03:28:45.000Z</published>
    <updated>2023-01-16T03:29:34.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Open-vSwitch"><a href="#Open-vSwitch" class="headerlink" title="Open vSwitch"></a>Open vSwitch</h4><p>Open vSwitch 是一个开源的虚拟交换机实现。广泛应用在云计算行业，为网络管理员提供虚拟云主机之间和之内的流量可见性与可控性。Open vSwitch 旨在用虚拟化方案解决网络问题，与控制器软件一起实现分布式的虚拟交换技术。这意味着，交换机和控制器软件能够在多个服务器之间创建集群网络配置，从而不需要在每一台云主机和物理主机上单独配置网络。这个交换机还支持 VLAN 中继，通过 NetFlow、sFlow 和 RSPAN 实现可见性，通过 OpenFlow 协议进行管理。它还有其他一些特性：严格流量控制，它由 OpenFlow 交换协议实现；远程管理功能，它能通过网络策略实现更多控制。</p><p>在虚拟交换机的 Flow 控制器或管理工具方面，OvS 需要借助第三方控制器或管理工具实现复杂的转发策略。例如 OvS 支持 OpenFlow 协议，我们就可以使用任何支持 OpenFlow 协议的控制器来对 OvS 进行远程管理。但这并不意味着 OvS 必须要有一个控制器才能工作。在不连接外部控制器情况下，OvS 自身可以依靠 MAC 地址学习实现二层数据包转发功能，就像 Linux Bridge。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Open-vSwitch&quot;&gt;&lt;a href=&quot;#Open-vSwitch&quot; class=&quot;headerlink&quot; title=&quot;Open vSwitch&quot;&gt;&lt;/a&gt;Open vSwitch&lt;/h4&gt;&lt;p&gt;Open vSwitch 是一个开源的虚拟交换机实现。广泛应</summary>
      
    
    
    
    
    <category term="ovs" scheme="https://robin5911.github.io/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>openstack-nova-虚拟机创建流程以及源码分析(二)</title>
    <link href="https://robin5911.github.io/2022/09/27/openstack-nova-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/"/>
    <id>https://robin5911.github.io/2022/09/27/openstack-nova-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/</id>
    <published>2022-09-27T06:05:41.000Z</published>
    <updated>2023-02-06T07:55:04.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="openstack-虚机创建流程以及源码分析-二"><a href="#openstack-虚机创建流程以及源码分析-二" class="headerlink" title="openstack 虚机创建流程以及源码分析(二)"></a>openstack 虚机创建流程以及源码分析(二)</h4><h6 id="基于openstack-stein"><a href="#基于openstack-stein" class="headerlink" title="基于openstack stein"></a>基于openstack stein</h6><p>前面调度完主机后开始rpc通知计算节点启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;conductor&#x2F;manager.py #</span><br><span class="line">def build_instances(self, context, instances, image, filter_properties,</span><br><span class="line">            admin_password, injected_files, requested_networks,</span><br><span class="line">            security_groups, block_device_mapping&#x3D;None, legacy_bdm&#x3D;True,</span><br><span class="line">            request_spec&#x3D;None, host_lists&#x3D;None):</span><br><span class="line">            .......................</span><br><span class="line">            self.compute_rpcapi.build_and_run_instance(context,</span><br><span class="line">                                instance&#x3D;instance, host&#x3D;host.service_host, image&#x3D;image,</span><br><span class="line">                                request_spec&#x3D;local_reqspec,</span><br><span class="line">                                filter_properties&#x3D;local_filter_props,</span><br><span class="line">                                admin_password&#x3D;admin_password,</span><br><span class="line">                                injected_files&#x3D;injected_files,</span><br><span class="line">                                requested_networks&#x3D;requested_networks,</span><br><span class="line">                                security_groups&#x3D;security_groups,</span><br><span class="line">                                block_device_mapping&#x3D;bdms, node&#x3D;host.nodename,</span><br><span class="line">                                limits&#x3D;host.limits, host_list&#x3D;host_list)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def build_and_run_instance(self, ctxt, instance, host, image, request_spec,</span><br><span class="line">            filter_properties, admin_password&#x3D;None, injected_files&#x3D;None,</span><br><span class="line">            requested_networks&#x3D;None, security_groups&#x3D;None,</span><br><span class="line">            block_device_mapping&#x3D;None, node&#x3D;None, limits&#x3D;None,</span><br><span class="line">            host_list&#x3D;None):</span><br><span class="line">            .........</span><br><span class="line">            cctxt.cast(ctxt, &#39;build_and_run_instance&#39;, **kwargs)</span><br></pre></td></tr></table></figure><p>自此消息cast 传给了compute 节点</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;compute&#x2F;manager.py</span><br><span class="line">def build_and_run_instance(self, context, instance, image, request_spec,</span><br><span class="line">                     filter_properties, admin_password&#x3D;None,</span><br><span class="line">                     injected_files&#x3D;None, requested_networks&#x3D;None,</span><br><span class="line">                     security_groups&#x3D;None, block_device_mapping&#x3D;None,</span><br><span class="line">                     node&#x3D;None, limits&#x3D;None, host_list&#x3D;None):</span><br><span class="line"></span><br><span class="line">        @utils.synchronized(instance.uuid)</span><br><span class="line">        def _locked_do_build_and_run_instance(*args, **kwargs):</span><br><span class="line">            # NOTE(danms): We grab the semaphore with the instance uuid</span><br><span class="line">            # locked because we could wait in line to build this instance</span><br><span class="line">            # for a while and we want to make sure that nothing else tries</span><br><span class="line">            # to do anything with this instance while we wait.</span><br><span class="line">            with self._build_semaphore:</span><br><span class="line">                try:</span><br><span class="line">                    result &#x3D; self._do_build_and_run_instance(*args, **kwargs)</span><br><span class="line">                .............................</span><br><span class="line">        utils.spawn_n(_locked_do_build_and_run_instance,</span><br><span class="line">                      context, instance, image, request_spec,</span><br><span class="line">                      filter_properties, admin_password, injected_files,</span><br><span class="line">                      requested_networks, security_groups,</span><br><span class="line">                      block_device_mapping, node, limits, host_list)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def _do_build_and_run_instance(self, context, instance, image,</span><br><span class="line">        request_spec, filter_properties, admin_password, injected_files,</span><br><span class="line">        requested_networks, security_groups, block_device_mapping,</span><br><span class="line">        node&#x3D;None, limits&#x3D;None, host_list&#x3D;None):</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        LOG.debug(&#39;Starting instance...&#39;, instance&#x3D;instance)</span><br><span class="line">        instance.vm_state &#x3D; vm_states.BUILDING</span><br><span class="line">        instance.task_state &#x3D; None</span><br><span class="line">        instance.save(expected_task_state&#x3D;</span><br><span class="line">                (task_states.SCHEDULING, None))</span><br><span class="line">    except exception.InstanceNotFound:</span><br><span class="line">        msg &#x3D; &#39;Instance disappeared before build.&#39;</span><br><span class="line">        LOG.debug(msg, instance&#x3D;instance)</span><br><span class="line">        return build_results.FAILED</span><br><span class="line">    except exception.UnexpectedTaskStateError as e:</span><br><span class="line">        LOG.debug(e.format_message(), instance&#x3D;instance)</span><br><span class="line">        return build_results.FAILED</span><br><span class="line"></span><br><span class="line">    # b64 decode the files to inject:</span><br><span class="line">    decoded_files &#x3D; self._decode_files(injected_files)</span><br><span class="line"></span><br><span class="line">    if limits is None:</span><br><span class="line">        limits &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    if node is None:</span><br><span class="line">        node &#x3D; self._get_nodename(instance, refresh&#x3D;True)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        with timeutils.StopWatch() as timer:</span><br><span class="line">            self._build_and_run_instance(context, instance, image,</span><br><span class="line">                    decoded_files, admin_password, requested_networks,</span><br><span class="line">                    security_groups, block_device_mapping, node, limits,</span><br><span class="line">                    filter_properties, request_spec)</span><br><span class="line">        LOG.info(&#39;Took %0.2f seconds to build instance.&#39;,</span><br><span class="line">                 timer.elapsed(), instance&#x3D;instance)</span><br><span class="line">        return build_results.ACTIVE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">def _build_and_run_instance(self, context, instance, image, injected_files,</span><br><span class="line">           admin_password, requested_networks, security_groups,</span><br><span class="line">           block_device_mapping, node, limits, filter_properties,</span><br><span class="line">           request_spec&#x3D;None):</span><br><span class="line">..............................</span><br><span class="line">try:</span><br><span class="line">           scheduler_hints &#x3D; self._get_scheduler_hints(filter_properties,</span><br><span class="line">                                                       request_spec)</span><br><span class="line">           with self.rt.instance_claim(context, instance, node, limits):</span><br><span class="line">               # NOTE(russellb) It&#39;s important that this validation be done</span><br><span class="line">               # *after* the resource tracker instance claim, as that is where</span><br><span class="line">               # the host is set on the instance.</span><br><span class="line">               self._validate_instance_group_policy(context, instance,</span><br><span class="line">                                                    scheduler_hints)</span><br><span class="line">               image_meta &#x3D; objects.ImageMeta.from_dict(image)</span><br><span class="line"></span><br><span class="line">               LOG.debug(&#39;image_meta:%s, image:%s&#39; % (image_meta, image))</span><br><span class="line">               # verify image checksum</span><br><span class="line">               if CONF.enable_verify_image_md5sum:</span><br><span class="line">                   self.driver.verify_image_md5sum(context, instance, image_meta.id)</span><br><span class="line"></span><br><span class="line">               request_group_resource_providers_mapping &#x3D; \</span><br><span class="line">                   self._get_request_group_mapping(request_spec)</span><br><span class="line"></span><br><span class="line">               with self._build_resources(context, instance,</span><br><span class="line">                       requested_networks, security_groups, image_meta,</span><br><span class="line">                       block_device_mapping,</span><br><span class="line">                       request_group_resource_providers_mapping) as resources:</span><br><span class="line">                   instance.vm_state &#x3D; vm_states.BUILDING</span><br><span class="line">                   instance.task_state &#x3D; task_states.SPAWNING</span><br><span class="line">                   # NOTE(JoshNang) This also saves the changes to the</span><br><span class="line">                   # instance from _allocate_network_async, as they aren&#39;t</span><br><span class="line">                   # saved in that function to prevent races.</span><br><span class="line">                   instance.save(expected_task_state&#x3D;</span><br><span class="line">                           task_states.BLOCK_DEVICE_MAPPING)</span><br><span class="line">                   block_device_info &#x3D; resources[&#39;block_device_info&#39;]</span><br><span class="line">                   network_info &#x3D; resources[&#39;network_info&#39;]</span><br><span class="line">                   allocs &#x3D; resources[&#39;allocations&#39;]</span><br><span class="line">                   LOG.debug(&#39;Start spawning the instance on the hypervisor.&#39;,</span><br><span class="line">                             instance&#x3D;instance)</span><br><span class="line">                   with timeutils.StopWatch() as timer:</span><br><span class="line">                       LOG.debug(&quot;_build_and_run_instance self.driver.spawn &quot;</span><br><span class="line">                                 &quot;image_meta:%s, block_device_info:%s&quot;</span><br><span class="line">                                 % (image_meta, block_device_info))</span><br><span class="line">                       self.driver.spawn(context, instance, image_meta,</span><br><span class="line">                                         injected_files, admin_password,</span><br><span class="line">                                         allocs, network_info&#x3D;network_info,</span><br><span class="line">                                         block_device_info&#x3D;block_device_info,</span><br><span class="line">                                         destroy_disks_on_failure&#x3D;True)</span><br><span class="line">                   LOG.info(&#39;Took %0.2f seconds to spawn the instance on &#39;</span><br><span class="line">                            &#39;the hypervisor.&#39;, timer.elapsed(),</span><br><span class="line">                            instance&#x3D;instance)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def _build_resources(self, context, instance, requested_networks,</span><br><span class="line">                         security_groups, image_meta, block_device_mapping,</span><br><span class="line">                         resource_provider_mapping):</span><br><span class="line">     try:</span><br><span class="line">            LOG.debug(&#39;Start building networks asynchronously for instance.&#39;,</span><br><span class="line">                      instance&#x3D;instance)</span><br><span class="line">            network_info &#x3D; self._build_networks_for_instance(context, instance,</span><br><span class="line">                    requested_networks, security_groups,</span><br><span class="line">                    resource_provider_mapping)</span><br><span class="line">           ..................</span><br><span class="line">    try:</span><br><span class="line">            # Perform any driver preparation work for the driver.</span><br><span class="line">            self.driver.prepare_for_spawn(instance)</span><br><span class="line"></span><br><span class="line">            # Depending on a virt driver, some network configuration is</span><br><span class="line">            # necessary before preparing block devices.</span><br><span class="line">            self.driver.prepare_networks_before_block_device_mapping(</span><br><span class="line">                instance, network_info)</span><br><span class="line"></span><br><span class="line">            # Verify that all the BDMs have a device_name set and assign a</span><br><span class="line">            # default to the ones missing it with the help of the driver.</span><br><span class="line">            self._default_block_device_names(instance, image_meta,</span><br><span class="line">                                             block_device_mapping)</span><br><span class="line"></span><br><span class="line">            LOG.debug(&#39;Start building block device mappings for instance.&#39;,</span><br><span class="line">                      instance&#x3D;instance)</span><br><span class="line">            instance.vm_state &#x3D; vm_states.BUILDING</span><br><span class="line">            instance.task_state &#x3D; task_states.BLOCK_DEVICE_MAPPING</span><br><span class="line">            instance.save()</span><br><span class="line"></span><br><span class="line">            block_device_info &#x3D; self._prep_block_device(context, instance,</span><br><span class="line">                    block_device_mapping)   </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class DriverVolImageBlockDevice(DriverVolumeBlockDevice):</span><br><span class="line"></span><br><span class="line">    _valid_source &#x3D; &#39;image&#39;</span><br><span class="line">    _proxy_as_attr_inherited &#x3D; set([&#39;image_id&#39;])</span><br><span class="line"></span><br><span class="line">    def attach(self, context, instance, volume_api,</span><br><span class="line">               virt_driver, wait_func&#x3D;None):</span><br><span class="line">        if not self.volume_id:</span><br><span class="line">            av_zone &#x3D; _get_volume_create_az_value(instance)</span><br><span class="line">            vol &#x3D; volume_api.create(context, self.volume_size,</span><br><span class="line">                                    &#39;&#39;, &#39;&#39;, image_id&#x3D;self.image_id,</span><br><span class="line">                                    volume_type&#x3D;self.volume_type,</span><br><span class="line">                                    availability_zone&#x3D;av_zone)</span><br><span class="line">            if wait_func:</span><br><span class="line">                self._call_wait_func(context, wait_func, volume_api, vol[&#39;id&#39;])</span><br><span class="line"></span><br><span class="line">            self.volume_id &#x3D; vol[&#39;id&#39;]</span><br><span class="line"></span><br><span class="line">            # TODO(mriedem): Create an attachment to reserve the volume and</span><br><span class="line">            # make us go down the new-style attach flow.</span><br><span class="line"></span><br><span class="line">        super(DriverVolImageBlockDevice, self).attach(</span><br><span class="line">            context, instance, volume_api, virt_driver)</span><br></pre></td></tr></table></figure><p>保存instance状态为BUILD状态，然后启用超时watch调用 self._build_and_run_instance,  build虚机时对镜像等相关进行检查 ， 再调用 self._build_resources 调用self._build_networks_for_instance异步准备分配网络并将instance task 更改为networking, 然后再将instance task 更改为block_device_mapping状态并调用self._prep_block_device开始调用cinder api创建volume并attach，再上报虚机信息到placement，至此准备基本做完了，将instance task状态变更为spawning ，再调用libvirt.spawn创建虚机了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;libvirt&#x2F;driver.py</span><br><span class="line">def spawn(self, context, instance, image_meta, injected_files,</span><br><span class="line">              admin_password, allocations, network_info&#x3D;None,</span><br><span class="line">              block_device_info&#x3D;None, destroy_disks_on_failure&#x3D;False):</span><br><span class="line">   .............</span><br><span class="line">   self._create_image(context, instance, disk_info[&#39;mapping&#39;],</span><br><span class="line">                           injection_info&#x3D;injection_info,</span><br><span class="line">                           block_device_info&#x3D;block_device_info)</span><br><span class="line">    xml &#x3D; self._get_guest_xml(context, instance, network_info,</span><br><span class="line">                                  disk_info, image_meta,</span><br><span class="line">                                  block_device_info&#x3D;block_device_info,</span><br><span class="line">                                  mdevs&#x3D;mdevs)</span><br><span class="line">        self._create_domain_and_network(</span><br><span class="line">            context, xml, instance, network_info,</span><br><span class="line">            block_device_info&#x3D;block_device_info,</span><br><span class="line">            post_xml_callback&#x3D;gen_confdrive,</span><br><span class="line">            destroy_disks_on_failure&#x3D;destroy_disks_on_failure)</span><br></pre></td></tr></table></figure><p>创建image镜像，准备xml信息，然后调用_create_domain_and_network 创建libvirt guest信息 以及网络vif等信息，进行 plug_vifs 以及根据所选的防火墙driver进行 配置基础的filter （Set up basic filtering (MAC, IP, and ARP spoofing protection) 以及准备虚机的basic 防火墙filter (放行dhcp udp 67/68端口等)，再直接调用libvirt 的driver启动虚机。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;openstack-虚机创建流程以及源码分析-二&quot;&gt;&lt;a href=&quot;#openstack-虚机创建流程以及源码分析-二&quot; class=&quot;headerlink&quot; title=&quot;openstack 虚机创建流程以及源码分析(二)&quot;&gt;&lt;/a&gt;openstack 虚机创建流程以及源码分析(二)&lt;/h4&gt;&lt;h6 id=&quot;基于openstack-stein&quot;&gt;&lt;a href=&quot;#基于openstack-stein&quot; class=&quot;headerlink&quot; title=&quot;基于openstack stein&quot;&gt;&lt;/a&gt;基于openstack stein&lt;/h6&gt;&lt;p&gt;前面调度完主机后开始rpc通知计算节点启动&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#nova&amp;#x2F;conductor&amp;#x2F;manager.py #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def build_instances(self, context, instances, image, filter_properties,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            admin_password, injected_files, requested_networks,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            security_groups, block_device_mapping&amp;#x3D;None, legacy_bdm&amp;#x3D;True,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            request_spec&amp;#x3D;None, host_lists&amp;#x3D;None):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .......................&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.compute_rpcapi.build_and_run_instance(context,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                instance&amp;#x3D;instance, host&amp;#x3D;host.service_host, image&amp;#x3D;image,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                request_spec&amp;#x3D;local_reqspec,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                filter_properties&amp;#x3D;local_filter_props,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                admin_password&amp;#x3D;admin_password,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                injected_files&amp;#x3D;injected_files,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                requested_networks&amp;#x3D;requested_networks,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                security_groups&amp;#x3D;security_groups,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                block_device_mapping&amp;#x3D;bdms, node&amp;#x3D;host.nodename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                limits&amp;#x3D;host.limits, host_list&amp;#x3D;host_list)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def build_and_run_instance(self, ctxt, instance, host, image, request_spec,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            filter_properties, admin_password&amp;#x3D;None, injected_files&amp;#x3D;None,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            requested_networks&amp;#x3D;None, security_groups&amp;#x3D;None,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            block_device_mapping&amp;#x3D;None, node&amp;#x3D;None, limits&amp;#x3D;None,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            host_list&amp;#x3D;None):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .........&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cctxt.cast(ctxt, &amp;#39;build_and_run_instance&amp;#39;, **kwargs)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;自此消息cast 传给了compute 节点&lt;/p&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>docker-容器使用ipvlan网络</title>
    <link href="https://robin5911.github.io/2022/09/19/docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8ipvlan%E7%BD%91%E7%BB%9C/"/>
    <id>https://robin5911.github.io/2022/09/19/docker-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8ipvlan%E7%BD%91%E7%BB%9C/</id>
    <published>2022-09-19T07:15:47.000Z</published>
    <updated>2022-09-19T10:27:54.268Z</updated>
    
    <content type="html"><![CDATA[<p>docker 容器使用 ipvlan 网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;docker 容器使用 ipvlan 网络&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="docker" scheme="https://robin5911.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>centos7-升级至4.* 内核</title>
    <link href="https://robin5911.github.io/2022/09/19/centos7-%E5%8D%87%E7%BA%A7%E8%87%B34-%E5%86%85%E6%A0%B8/"/>
    <id>https://robin5911.github.io/2022/09/19/centos7-%E5%8D%87%E7%BA%A7%E8%87%B34-%E5%86%85%E6%A0%B8/</id>
    <published>2022-09-19T06:40:55.000Z</published>
    <updated>2022-09-30T09:35:02.028Z</updated>
    
    <content type="html"><![CDATA[<h4 id="因3-10内核部分功能不支持-所以考虑将CentOS-7-9-系统内核升级至-4-18"><a href="#因3-10内核部分功能不支持-所以考虑将CentOS-7-9-系统内核升级至-4-18" class="headerlink" title="因3.10内核部分功能不支持,所以考虑将CentOS 7.9 系统内核升级至 4.18"></a>因3.10内核部分功能不支持,所以考虑将CentOS 7.9 系统内核升级至 4.18</h4><h6 id="当前内核"><a href="#当前内核" class="headerlink" title="当前内核"></a>当前内核</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unama -a</span><br></pre></td></tr></table></figure><h6 id="安装内核库"><a href="#安装内核库" class="headerlink" title="安装内核库"></a>安装内核库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line">yum install -y https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><a id="more"></a><h6 id="查看内核列表"><a href="#查看内核列表" class="headerlink" title="查看内核列表"></a>查看内核列表</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo&#x3D;&quot;*&quot; --enablerepo&#x3D;&quot;elrepo-kernel&quot; list available</span><br></pre></td></tr></table></figure><h6 id="安装内核长期支持版本-PS-这里安装的最新版本"><a href="#安装内核长期支持版本-PS-这里安装的最新版本" class="headerlink" title="安装内核长期支持版本(PS: 这里安装的最新版本)"></a>安装内核长期支持版本(PS: 这里安装的最新版本)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo&#x3D;elrepo-kernel install kernel-lt-devel kernel-lt -y</span><br></pre></td></tr></table></figure><h6 id="查看系统上可使用的内核"><a href="#查看系统上可使用的内核" class="headerlink" title="查看系统上可使用的内核"></a>查看系统上可使用的内核</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F\&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;etc&#x2F;grub2.cfg</span><br></pre></td></tr></table></figure><h6 id="设置新内核为grub2的默认版本"><a href="#设置新内核为grub2的默认版本" class="headerlink" title="设置新内核为grub2的默认版本"></a>设置新内核为grub2的默认版本</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure><h6 id="生成grub配置文件"><a href="#生成grub配置文件" class="headerlink" title="生成grub配置文件"></a>生成grub配置文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><h6 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;因3-10内核部分功能不支持-所以考虑将CentOS-7-9-系统内核升级至-4-18&quot;&gt;&lt;a href=&quot;#因3-10内核部分功能不支持-所以考虑将CentOS-7-9-系统内核升级至-4-18&quot; class=&quot;headerlink&quot; title=&quot;因3.10内核部分功能不支持,所以考虑将CentOS 7.9 系统内核升级至 4.18&quot;&gt;&lt;/a&gt;因3.10内核部分功能不支持,所以考虑将CentOS 7.9 系统内核升级至 4.18&lt;/h4&gt;&lt;h6 id=&quot;当前内核&quot;&gt;&lt;a href=&quot;#当前内核&quot; class=&quot;headerlink&quot; title=&quot;当前内核&quot;&gt;&lt;/a&gt;当前内核&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unama -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h6 id=&quot;安装内核库&quot;&gt;&lt;a href=&quot;#安装内核库&quot; class=&quot;headerlink&quot; title=&quot;安装内核库&quot;&gt;&lt;/a&gt;安装内核库&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rpm --import https:&amp;#x2F;&amp;#x2F;www.elrepo.org&amp;#x2F;RPM-GPG-KEY-elrepo.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y https:&amp;#x2F;&amp;#x2F;www.elrepo.org&amp;#x2F;elrepo-release-7.el7.elrepo.noarch.rpm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://robin5911.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>openstack-nova-虚拟机创建流程以及源码分析(一)</title>
    <link href="https://robin5911.github.io/2022/09/19/openstack-nova-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://robin5911.github.io/2022/09/19/openstack-nova-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2022-09-19T02:26:20.000Z</published>
    <updated>2022-09-30T09:28:50.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="openstack-虚机创建流程以及源码分析-一"><a href="#openstack-虚机创建流程以及源码分析-一" class="headerlink" title="openstack 虚机创建流程以及源码分析(一)"></a>openstack 虚机创建流程以及源码分析(一)</h4><h6 id="基于openstack-stein"><a href="#基于openstack-stein" class="headerlink" title="基于openstack stein"></a>基于openstack stein</h6><h6 id="虚机创建流程图"><a href="#虚机创建流程图" class="headerlink" title="虚机创建流程图"></a>虚机创建流程图</h6><p><img src="/images/openstack/instance-creation.png"></p><p>上图是虚拟机创建流程的整体流程，可以看到整体虚拟机创建流程一次经过了API、Conductor、Scheduler、Placement、Compute等主要服务。</p><p><strong>下表列出了每个步骤中实例的状态：</strong></p><table><thead><tr><th><strong>Status</strong></th><th><strong>Task</strong></th><th><strong>Power state</strong></th><th><strong>Steps</strong></th></tr></thead><tbody><tr><td>Build</td><td>scheduling</td><td>None</td><td>3-12</td></tr><tr><td>Build</td><td>networking</td><td>None</td><td>22-24</td></tr><tr><td>Build</td><td>block_device_mapping</td><td>None</td><td>25-27</td></tr><tr><td>Build</td><td>spawing</td><td>None</td><td>28</td></tr><tr><td>Active</td><td>none</td><td>Running</td><td></td></tr></tbody></table><h6 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h6><p>首先对从HTTP请求的获取的req和body中的相关信息进行验证，验证完成后调用nova-api的create函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;api&#x2F;openstack&#x2F;compute&#x2F;servers.py #ServersController</span><br><span class="line">def create(self, req, body):</span><br><span class="line">......................</span><br><span class="line">self._process_bdms_for_create(</span><br><span class="line">            context, target, server_dict, create_kwargs,</span><br><span class="line">            supports_device_tagging)</span><br><span class="line"></span><br><span class="line">        image_uuid &#x3D; self._image_from_req_data(server_dict, create_kwargs)</span><br><span class="line"></span><br><span class="line">        self._process_networks_for_create(</span><br><span class="line">            context, target, server_dict, create_kwargs,</span><br><span class="line">            supports_device_tagging)</span><br><span class="line"></span><br><span class="line">        flavor_id &#x3D; self._flavor_id_from_req_data(body)</span><br><span class="line">        try:</span><br><span class="line">            inst_type &#x3D; flavors.get_flavor_by_flavor_id(</span><br><span class="line">                    flavor_id, ctxt&#x3D;context, read_deleted&#x3D;&quot;no&quot;)</span><br><span class="line"></span><br><span class="line">            supports_multiattach &#x3D; common.supports_multiattach_volume(req)</span><br><span class="line">            supports_port_resource_request &#x3D; \</span><br><span class="line">                common.supports_port_resource_request(req)</span><br><span class="line">            (instances, resv_id) &#x3D; self.compute_api.create(context,</span><br><span class="line">                inst_type,</span><br><span class="line">                image_uuid,</span><br><span class="line">                display_name&#x3D;name,</span><br><span class="line">                display_description&#x3D;description,</span><br><span class="line">                availability_zone&#x3D;availability_zone,</span><br><span class="line">                forced_host&#x3D;host, forced_node&#x3D;node,</span><br><span class="line">                metadata&#x3D;server_dict.get(&#39;metadata&#39;, &#123;&#125;),</span><br><span class="line">                admin_password&#x3D;password,</span><br><span class="line">                check_server_group_quota&#x3D;True,</span><br><span class="line">                supports_multiattach&#x3D;supports_multiattach,</span><br><span class="line">                supports_port_resource_request&#x3D;supports_port_resource_request,</span><br><span class="line">                **create_kwargs)</span><br><span class="line">        except (exception.QuotaError,</span><br><span class="line">                exception.PortLimitExceeded) as error:</span><br><span class="line">            raise exc.HTTPForbidden(</span><br><span class="line">                explanation&#x3D;error.format_message())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中nova-api有两种类型，即根据配置参数进行选择self.compute_api的类型。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;compute&#x2F;__init__.py</span><br><span class="line">CELL_TYPE_TO_CLS_NAME &#x3D; &#123;&#39;api&#39;: &#39;nova.compute.cells_api.ComputeCellsAPI&#39;,</span><br><span class="line">                         &#39;compute&#39;: &#39;nova.compute.api.API&#39;,</span><br><span class="line">                         None: &#39;nova.compute.api.API&#39;,</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _get_compute_api_class_name():</span><br><span class="line">    &quot;&quot;&quot;Returns the name of compute API class.&quot;&quot;&quot;</span><br><span class="line">    cell_type &#x3D; nova.cells.opts.get_cell_type()</span><br><span class="line">    return CELL_TYPE_TO_CLS_NAME[cell_type]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def API(*args, **kwargs):</span><br><span class="line">    class_name &#x3D; _get_compute_api_class_name()</span><br><span class="line">    return importutils.import_object(class_name, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即根据/etc/nova/nova.conf配置文件cells字段下面的enable参数来设置nova-api的类型，由于我们的环境采用默认配置，stein版本默认cell v2就是打开的，即enable=true，所以get_cell_type函数将返回api 值，因此nova-api为nova.compute.cells_api.ComputeCellsAPI，即self.compute_api为nova.compute.cells_api.ComputeCellsAPI对象。所以将会调用nova.compute.cells_api.ComputeCellsAPI中的create函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;compute&#x2F;cells_api.py</span><br><span class="line">class ComputeCellsAPI(compute_api.API):</span><br><span class="line">    def create(self, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;We can use the base functionality, but I left this here just</span><br><span class="line">        for completeness.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return super(ComputeCellsAPI, self).create(*args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nova.compute.cells_api.ComputeCellsAPI中的create函数, 这里默认调用的父类 nova.compute.api中的create函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;compute&#x2F;api.py</span><br><span class="line">    def create(self, context, instance_type,</span><br><span class="line">               image_href, kernel_id&#x3D;None, ramdisk_id&#x3D;None,</span><br><span class="line">               min_count&#x3D;None, max_count&#x3D;None,</span><br><span class="line">               display_name&#x3D;None, display_description&#x3D;None,</span><br><span class="line">               key_name&#x3D;None, key_data&#x3D;None, security_groups&#x3D;None,</span><br><span class="line">               availability_zone&#x3D;None, forced_host&#x3D;None, forced_node&#x3D;None,</span><br><span class="line">               user_data&#x3D;None, metadata&#x3D;None, injected_files&#x3D;None,</span><br><span class="line">               admin_password&#x3D;None, block_device_mapping&#x3D;None,</span><br><span class="line">               access_ip_v4&#x3D;None, access_ip_v6&#x3D;None, requested_networks&#x3D;None,</span><br><span class="line">               config_drive&#x3D;None, auto_disk_config&#x3D;None, scheduler_hints&#x3D;None,</span><br><span class="line">               legacy_bdm&#x3D;True, shutdown_terminate&#x3D;False,</span><br><span class="line">               check_server_group_quota&#x3D;False, tags&#x3D;None,</span><br><span class="line">               supports_multiattach&#x3D;False, trusted_certs&#x3D;None,</span><br><span class="line">               supports_port_resource_request&#x3D;False):</span><br><span class="line">        &quot;&quot;&quot;Provision instances, sending instance information to the</span><br><span class="line">        scheduler.  The scheduler will determine where the instance(s)</span><br><span class="line">        go and will handle creating the DB entries.</span><br><span class="line"></span><br><span class="line">        Returns a tuple of (instances, reservation_id)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if requested_networks and max_count is not None and max_count &gt; 1:</span><br><span class="line">            self._check_multiple_instances_with_specified_ip(</span><br><span class="line">                requested_networks)</span><br><span class="line">            if utils.is_neutron():</span><br><span class="line">                self._check_multiple_instances_with_neutron_ports(</span><br><span class="line">                    requested_networks)</span><br><span class="line"></span><br><span class="line">        if availability_zone:</span><br><span class="line">            available_zones &#x3D; availability_zones.\</span><br><span class="line">                get_availability_zones(context.elevated(), True)</span><br><span class="line">            if forced_host is None and availability_zone not in \</span><br><span class="line">                    available_zones:</span><br><span class="line">                msg &#x3D; _(&#39;The requested availability zone is not available&#39;)</span><br><span class="line">                raise exception.InvalidRequest(msg)</span><br><span class="line"></span><br><span class="line">        filter_properties &#x3D; scheduler_utils.build_filter_properties(</span><br><span class="line">                scheduler_hints, forced_host, forced_node, instance_type)</span><br><span class="line"></span><br><span class="line">        return self._create_instance(</span><br><span class="line">            context, instance_type,</span><br><span class="line">            image_href, kernel_id, ramdisk_id,</span><br><span class="line">            min_count, max_count,</span><br><span class="line">            display_name, display_description,</span><br><span class="line">            key_name, key_data, security_groups,</span><br><span class="line">            availability_zone, user_data, metadata,</span><br><span class="line">            injected_files, admin_password,</span><br><span class="line">            access_ip_v4, access_ip_v6,</span><br><span class="line">            requested_networks, config_drive,</span><br><span class="line">            block_device_mapping, auto_disk_config,</span><br><span class="line">            filter_properties&#x3D;filter_properties,</span><br><span class="line">            legacy_bdm&#x3D;legacy_bdm,</span><br><span class="line">            shutdown_terminate&#x3D;shutdown_terminate,</span><br><span class="line">            check_server_group_quota&#x3D;check_server_group_quota,</span><br><span class="line">            tags&#x3D;tags, supports_multiattach&#x3D;supports_multiattach,</span><br><span class="line">            trusted_certs&#x3D;trusted_certs,</span><br><span class="line">            supports_port_resource_request&#x3D;supports_port_resource_request)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;compute&#x2F;api.py</span><br><span class="line">def _create_instance(self, context, instance_type,</span><br><span class="line">               image_href, kernel_id, ramdisk_id,</span><br><span class="line">               min_count, max_count,</span><br><span class="line">               display_name, display_description,</span><br><span class="line">               key_name, key_data, security_groups,</span><br><span class="line">               availability_zone, user_data, metadata, injected_files,</span><br><span class="line">               admin_password, access_ip_v4, access_ip_v6,</span><br><span class="line">               requested_networks, config_drive,</span><br><span class="line">               block_device_mapping, auto_disk_config, filter_properties,</span><br><span class="line">               reservation_id&#x3D;None, legacy_bdm&#x3D;True, shutdown_terminate&#x3D;False,</span><br><span class="line">               check_server_group_quota&#x3D;False, tags&#x3D;None,</span><br><span class="line">               supports_multiattach&#x3D;False, trusted_certs&#x3D;None,</span><br><span class="line">               supports_port_resource_request&#x3D;False):</span><br><span class="line">        ..............</span><br><span class="line">self._checks_for_create_and_rebuild(context, image_id, boot_meta,</span><br><span class="line">                instance_type, metadata, injected_files,</span><br><span class="line">                block_device_mapping.root_bdm(), validate_numa&#x3D;False)</span><br><span class="line"></span><br><span class="line">        instance_group &#x3D; self._get_requested_instance_group(context,</span><br><span class="line">                                   filter_properties)</span><br><span class="line"></span><br><span class="line">        tags &#x3D; self._create_tag_list_obj(context, tags)</span><br><span class="line"></span><br><span class="line">        instances_to_build &#x3D; self._provision_instances(</span><br><span class="line">            context, instance_type, min_count, max_count, base_options,</span><br><span class="line">            boot_meta, security_groups, block_device_mapping,</span><br><span class="line">            shutdown_terminate, instance_group, check_server_group_quota,</span><br><span class="line">            filter_properties, key_pair, tags, trusted_certs,</span><br><span class="line">            supports_multiattach, network_metadata)      </span><br><span class="line">                if CONF.cells.enable:</span><br><span class="line">            # NOTE(danms): CellsV1 can&#39;t do the new thing, so we</span><br><span class="line">            # do the old thing here. We can remove this path once</span><br><span class="line">            # we stop supporting v1.</span><br><span class="line">            for instance in instances:</span><br><span class="line">                instance.create()</span><br><span class="line">            # NOTE(melwitt): We recheck the quota after creating the objects</span><br><span class="line">            # to prevent users from allocating more resources than their</span><br><span class="line">            # allowed quota in the event of a race. This is configurable</span><br><span class="line">            # because it can be expensive if strict quota limits are not</span><br><span class="line">            # required in a deployment.</span><br><span class="line">            if CONF.quota.recheck_quota:</span><br><span class="line">                try:</span><br><span class="line">                    compute_utils.check_num_instances_quota(</span><br><span class="line">                        context, instance_type, 0, 0,</span><br><span class="line">                        orig_num_req&#x3D;len(instances))</span><br><span class="line">                except exception.TooManyInstances:</span><br><span class="line">                    with excutils.save_and_reraise_exception():</span><br><span class="line">                        # Need to clean up all the instances we created</span><br><span class="line">                        # along with the build requests, request specs,</span><br><span class="line">                        # and instance mappings.</span><br><span class="line">                        self._cleanup_build_artifacts(instances,</span><br><span class="line">                                                      instances_to_build)</span><br><span class="line"></span><br><span class="line">            self.compute_task_api.build_instances(context,</span><br><span class="line">                instances&#x3D;instances, image&#x3D;boot_meta,</span><br><span class="line">                filter_properties&#x3D;filter_properties,</span><br><span class="line">                admin_password&#x3D;admin_password,</span><br><span class="line">                injected_files&#x3D;injected_files,</span><br><span class="line">                requested_networks&#x3D;requested_networks,</span><br><span class="line">                security_groups&#x3D;security_groups,</span><br><span class="line">                block_device_mapping&#x3D;block_device_mapping,</span><br><span class="line">                legacy_bdm&#x3D;False)</span><br></pre></td></tr></table></figure><p>这里调用 _create_instance创建虚拟机，nova-api 在数据库中 为新实例创建一个数据库条目，最终调用 compute_task_api.build_instances 创建虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;conductor&#x2F;api.py</span><br><span class="line">    def build_instances(self, context, instances, image, filter_properties,</span><br><span class="line">            admin_password, injected_files, requested_networks,</span><br><span class="line">            security_groups, block_device_mapping, legacy_bdm&#x3D;True,</span><br><span class="line">            request_spec&#x3D;None, host_lists&#x3D;None):</span><br><span class="line">        self.conductor_compute_rpcapi.build_instances(context,</span><br><span class="line">                instances&#x3D;instances, image&#x3D;image,</span><br><span class="line">                filter_properties&#x3D;filter_properties,</span><br><span class="line">                admin_password&#x3D;admin_password, injected_files&#x3D;injected_files,</span><br><span class="line">                requested_networks&#x3D;requested_networks,</span><br><span class="line">                security_groups&#x3D;security_groups,</span><br><span class="line">                block_device_mapping&#x3D;block_device_mapping,</span><br><span class="line">                legacy_bdm&#x3D;legacy_bdm, request_spec&#x3D;request_spec,</span><br><span class="line">                host_lists&#x3D;host_lists)</span><br></pre></td></tr></table></figure><p>消息调用conductor的rpcapi 接口从而传给conductor，让它来build instance</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;api&#x2F;openstack&#x2F;server.py</span><br><span class="line">def build_instances(self, context, instances, image, filter_properties,</span><br><span class="line">            admin_password, injected_files, requested_networks,</span><br><span class="line">            security_groups, block_device_mapping, legacy_bdm&#x3D;True,</span><br><span class="line">            request_spec&#x3D;None, host_lists&#x3D;None):</span><br><span class="line">    ..........</span><br><span class="line">cctxt.cast(context, &#39;build_instances&#39;, **kwargs)</span><br></pre></td></tr></table></figure><p>为什么通过RPC的cast调用就会调用到该位置的build_instances函数呢？这是因为在nova-conductor服务启动时，会去创建相关的RPC-server，而这些RPC-server创建时候将会去指定一些endpoints(与keystone中的endpoints含义不同，这里只是名称相同而已)，而这些endpoints中包括一些对象列表，当RPC-client去调用相应的RPC-server中的函数时，则会在这些endpoints的对象列表中进行查找，然后调用相应的函数，具体可以看下 <em>#/nova/service.py:Service</em> start 流程， 更加详细的可以查询openstack rpc相关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;conductor&#x2F;manager.py</span><br><span class="line">def build_instances(self, context, instances, image, filter_properties,</span><br><span class="line">            admin_password, injected_files, requested_networks,</span><br><span class="line">            security_groups, block_device_mapping&#x3D;None, legacy_bdm&#x3D;True,</span><br><span class="line">            request_spec&#x3D;None, host_lists&#x3D;None):</span><br><span class="line">            </span><br><span class="line"> try:</span><br><span class="line">            # check retry policy. Rather ugly use of instances[0]...</span><br><span class="line">            # but if we&#39;ve exceeded max retries... then we really only</span><br><span class="line">            # have a single instance.</span><br><span class="line">            # TODO(sbauza): Provide directly the RequestSpec object</span><br><span class="line">            # when populate_retry() accepts it</span><br><span class="line">            scheduler_utils.populate_retry(</span><br><span class="line">                filter_properties, instances[0].uuid)</span><br><span class="line">            instance_uuids &#x3D; [instance.uuid for instance in instances]</span><br><span class="line">            spec_obj &#x3D; objects.RequestSpec.from_primitives(</span><br><span class="line">                    context, legacy_request_spec, filter_properties)</span><br><span class="line">            LOG.debug(&quot;Rescheduling: %s&quot;, is_reschedule)</span><br><span class="line">            if is_reschedule:</span><br><span class="line">                # Make sure that we have a host, as we may have exhausted all</span><br><span class="line">                # our alternates</span><br><span class="line">                if not host_lists[0]:</span><br><span class="line">                    # We have an empty list of hosts, so this instance has</span><br><span class="line">                    # failed to build.</span><br><span class="line">                    msg &#x3D; (&quot;Exhausted all hosts available for retrying build &quot;</span><br><span class="line">                           &quot;failures for instance %(instance_uuid)s.&quot; %</span><br><span class="line">                           &#123;&quot;instance_uuid&quot;: instances[0].uuid&#125;)</span><br><span class="line">                    raise exception.MaxRetriesExceeded(reason&#x3D;msg)</span><br><span class="line">            else:</span><br><span class="line">                # This is not a reschedule, so we need to call the scheduler to</span><br><span class="line">                # get appropriate hosts for the request.</span><br><span class="line">                # NOTE(gibi): We only call the scheduler if using cells v1 or</span><br><span class="line">                # we are rescheduling from a really old compute. In</span><br><span class="line">                # either case we do not support externally-defined resource</span><br><span class="line">                # requests, like port QoS. So no requested_resources are set</span><br><span class="line">                # on the RequestSpec here.</span><br><span class="line">                host_lists &#x3D; self._schedule_instances(context, spec_obj,</span><br><span class="line">                        instance_uuids, return_alternates&#x3D;True)</span><br></pre></td></tr></table></figure><p>第一次不会重新调度，调用 _schedule_instances 里的 self.query_client.select_destinations 选择计算节点，conductor调用scheduler client 发起rpc请求 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;scheduler&#x2F;client&#x2F;query.py</span><br><span class="line">class SchedulerQueryClient(object):</span><br><span class="line">    &quot;&quot;&quot;Client class for querying to the scheduler.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.scheduler_rpcapi &#x3D; scheduler_rpcapi.SchedulerAPI()</span><br><span class="line"></span><br><span class="line">    def select_destinations(self, context, spec_obj, instance_uuids,</span><br><span class="line">            return_objects&#x3D;False, return_alternates&#x3D;False):</span><br><span class="line">        &quot;&quot;&quot;Returns destinations(s) best suited for this request_spec and</span><br><span class="line">        filter_properties.</span><br><span class="line"></span><br><span class="line">        When return_objects is False, the result will be the &quot;old-style&quot; list</span><br><span class="line">        of dicts with &#39;host&#39;, &#39;nodename&#39; and &#39;limits&#39; as keys. The value of</span><br><span class="line">        return_alternates is ignored.</span><br><span class="line"></span><br><span class="line">        When return_objects is True, the result will be a list of lists of</span><br><span class="line">        Selection objects, with one list per instance. Each instance&#39;s list</span><br><span class="line">        will contain a Selection representing the selected (and claimed) host,</span><br><span class="line">        and, if return_alternates is True, zero or more Selection objects that</span><br><span class="line">        represent alternate hosts. The number of alternates returned depends on</span><br><span class="line">        the configuration setting &#96;CONF.scheduler.max_attempts&#96;.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.scheduler_rpcapi.select_destinations(context, spec_obj,</span><br><span class="line">                instance_uuids, return_objects, return_alternates)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;scheduler&#x2F;rpcapi.py</span><br><span class="line">    def select_destinations(self, ctxt, spec_obj, instance_uuids,</span><br><span class="line">            return_objects&#x3D;False, return_alternates&#x3D;False):</span><br><span class="line">        # Modify the parameters if an older version is requested</span><br><span class="line">        .................</span><br><span class="line">        return cctxt.call(ctxt, &#39;select_destinations&#39;, **msg_args)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消息通过rpc请求发给了scheduler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;scheduler&#x2F;manager.py</span><br><span class="line">def select_destinations(self, ctxt, request_spec&#x3D;None,</span><br><span class="line">            filter_properties&#x3D;None, spec_obj&#x3D;_sentinel, instance_uuids&#x3D;None,</span><br><span class="line">            return_objects&#x3D;False, return_alternates&#x3D;False):</span><br><span class="line">        .........................</span><br><span class="line">        if self.driver.USES_ALLOCATION_CANDIDATES and not is_rebuild:</span><br><span class="line">            # Only process the Placement request spec filters when Placement</span><br><span class="line">            # is used.</span><br><span class="line">            try:</span><br><span class="line">                request_filter.process_reqspec(ctxt, spec_obj)</span><br><span class="line">            except exception.RequestFilterFailed as e:</span><br><span class="line">                raise exception.NoValidHost(reason&#x3D;e.message)</span><br><span class="line"></span><br><span class="line">            resources &#x3D; utils.resources_from_request_spec(spec_obj)</span><br><span class="line">            res &#x3D; self.placement_client.get_allocation_candidates(ctxt,</span><br><span class="line">                                                                  resources)</span><br><span class="line">            if res is None:</span><br><span class="line">                # We have to handle the case that we failed to connect to the</span><br><span class="line">                # Placement service and the safe_connect decorator on</span><br><span class="line">                # get_allocation_candidates returns None.</span><br><span class="line">                alloc_reqs, provider_summaries, allocation_request_version &#x3D; (</span><br><span class="line">                        None, None, None)</span><br><span class="line">            else:</span><br><span class="line">                (alloc_reqs, provider_summaries,</span><br><span class="line">                            allocation_request_version) &#x3D; res</span><br><span class="line">            if not alloc_reqs:</span><br><span class="line">                LOG.info(&quot;Got no allocation candidates from the Placement &quot;</span><br><span class="line">                         &quot;API. This could be due to insufficient resources &quot;</span><br><span class="line">                         &quot;or a temporary occurrence as compute nodes start &quot;</span><br><span class="line">                         &quot;up.&quot;)</span><br><span class="line">                raise exception.NoValidHost(reason&#x3D;&quot;&quot;)</span><br><span class="line">            else:</span><br><span class="line">                # Build a dict of lists of allocation requests, keyed by</span><br><span class="line">                # provider UUID, so that when we attempt to claim resources for</span><br><span class="line">                # a host, we can grab an allocation request easily</span><br><span class="line">                alloc_reqs_by_rp_uuid &#x3D; collections.defaultdict(list)</span><br><span class="line">                for ar in alloc_reqs:</span><br><span class="line">                    for rp_uuid in ar[&#39;allocations&#39;]:</span><br><span class="line">                        alloc_reqs_by_rp_uuid[rp_uuid].append(ar)</span><br><span class="line"></span><br><span class="line">        # Only return alternates if both return_objects and return_alternates</span><br><span class="line">        # are True.</span><br><span class="line">        return_alternates &#x3D; return_alternates and return_objects</span><br><span class="line">        selections &#x3D; self.driver.select_destinations(ctxt, spec_obj,</span><br><span class="line">                instance_uuids, alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">                allocation_request_version, return_alternates)</span><br><span class="line">        # If &#96;return_objects&#96; is False, we need to convert the selections to</span><br><span class="line">        # the older format, which is a list of host state dicts.</span><br><span class="line">        if not return_objects:</span><br><span class="line">            selection_dicts &#x3D; [sel[0].to_dict() for sel in selections]</span><br><span class="line">            return jsonutils.to_primitive(selection_dicts)</span><br><span class="line">        return selections</span><br></pre></td></tr></table></figure><p>scheduler选择目标节点时会查询placement选择合适候选人 , 再调用 scheduler自身的filter 选择节点 self.driver.select_destinations</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#nova&#x2F;scheduler&#x2F;filter_scheduler.py</span><br><span class="line">def select_destinations(self, context, spec_obj, instance_uuids,</span><br><span class="line">            alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">            allocation_request_version&#x3D;None, return_alternates&#x3D;False):</span><br><span class="line">.....................</span><br><span class="line">        host_selections &#x3D; self._schedule(context, spec_obj, instance_uuids,</span><br><span class="line">                alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">                allocation_request_version, return_alternates)</span><br><span class="line">        self.notifier.info(</span><br><span class="line">            context, &#39;scheduler.select_destinations.end&#39;,</span><br><span class="line">            dict(request_spec&#x3D;spec_obj.to_legacy_request_spec_dict()))</span><br><span class="line">        compute_utils.notify_about_scheduler_action(</span><br><span class="line">            context&#x3D;context, request_spec&#x3D;spec_obj,</span><br><span class="line">            action&#x3D;fields_obj.NotificationAction.SELECT_DESTINATIONS,</span><br><span class="line">            phase&#x3D;fields_obj.NotificationPhase.END)</span><br><span class="line">        return host_selections</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def _schedule(self, context, spec_obj, instance_uuids,</span><br><span class="line">            alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">            allocation_request_version&#x3D;None, return_alternates&#x3D;False):</span><br><span class="line">    .......        </span><br><span class="line">    hosts &#x3D; self._get_all_host_states(elevated, spec_obj,</span><br><span class="line">                provider_summaries) </span><br><span class="line">.........</span><br><span class="line">for num, instance_uuid in enumerate(instance_uuids):</span><br><span class="line">hosts &#x3D; self._get_sorted_hosts(spec_obj, hosts, num)</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"># Check if we were able to fulfill the request. If not, this call will</span><br><span class="line">        # raise a NoValidHost exception.</span><br><span class="line">        self._ensure_sufficient_hosts(context, claimed_hosts, num_instances,</span><br><span class="line">                claimed_instance_uuids)</span><br></pre></td></tr></table></figure><p>获取前面placement 候选人 resource provider的主机状态信息, select_destinations 调度选择好计算节点</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;openstack-虚机创建流程以及源码分析-一&quot;&gt;&lt;a href=&quot;#openstack-虚机创建流程以及源码分析-一&quot; class=&quot;headerlink&quot; title=&quot;openstack 虚机创建流程以及源码分析(一)&quot;&gt;&lt;/a&gt;openstack 虚机创建流程以及源码分析(一)&lt;/h4&gt;&lt;h6 id=&quot;基于openstack-stein&quot;&gt;&lt;a href=&quot;#基于openstack-stein&quot; class=&quot;headerlink&quot; title=&quot;基于openstack stein&quot;&gt;&lt;/a&gt;基于openstack stein&lt;/h6&gt;&lt;h6 id=&quot;虚机创建流程图&quot;&gt;&lt;a href=&quot;#虚机创建流程图&quot; class=&quot;headerlink&quot; title=&quot;虚机创建流程图&quot;&gt;&lt;/a&gt;虚机创建流程图&lt;/h6&gt;&lt;p&gt;&lt;img src=&quot;/images/openstack/instance-creation.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是虚拟机创建流程的整体流程，可以看到整体虚拟机创建流程一次经过了API、Conductor、Scheduler、Placement、Compute等主要服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下表列出了每个步骤中实例的状态：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Power state&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Steps&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Build&lt;/td&gt;
&lt;td&gt;scheduling&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;3-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Build&lt;/td&gt;
&lt;td&gt;networking&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;22-24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Build&lt;/td&gt;
&lt;td&gt;block_device_mapping&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;25-27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Build&lt;/td&gt;
&lt;td&gt;spawing&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Active&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;Running&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h6 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-placement-常用命令</title>
    <link href="https://robin5911.github.io/2022/09/13/openstack-placement-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://robin5911.github.io/2022/09/13/openstack-placement-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-09-13T08:03:45.000Z</published>
    <updated>2022-09-13T09:45:00.034Z</updated>
    
    <content type="html"><![CDATA[<h6 id="查询resource-class"><a href="#查询resource-class" class="headerlink" title="查询resource class"></a>查询resource class</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#openstack resource class list</span><br></pre></td></tr></table></figure><h6 id="查询候选人列表"><a href="#查询候选人列表" class="headerlink" title="查询候选人列表"></a>查询候选人列表</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#openstack allocation candidate list --resource VCPU&#x3D;16 --resource MEMORY_MB&#x3D;32768 --resource DISK_GB&#x3D;100 --required CUSTOM_ENT_CLOUD_HOST</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;查询resource-class&quot;&gt;&lt;a href=&quot;#查询resource-class&quot; class=&quot;headerlink&quot; title=&quot;查询resource class&quot;&gt;&lt;/a&gt;查询resource class&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#openstack resource class list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h6 id=&quot;查询候选人列表&quot;&gt;&lt;a href=&quot;#查询候选人列表&quot; class=&quot;headerlink&quot; title=&quot;查询候选人列表&quot;&gt;&lt;/a&gt;查询候选人列表&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#openstack allocation candidate list --resource VCPU&amp;#x3D;16 --resource MEMORY_MB&amp;#x3D;32768 --resource DISK_GB&amp;#x3D;100 --required CUSTOM_ENT_CLOUD_HOST&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-记一次虚机创建失败问题</title>
    <link href="https://robin5911.github.io/2022/08/15/openstack-%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%99%9A%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://robin5911.github.io/2022/08/15/openstack-%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%99%9A%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-15T09:26:28.000Z</published>
    <updated>2022-08-15T10:01:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>d</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某天，突然openstack无法创建虚拟机，MQ消息大量堆积</p><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><ol><li>nova-conductor报大量数据库超时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[SQL: UPDATE services SET updated_at&#x3D;%(updated_at)s, report_count&#x3D;%(report_count)s, last_seen_up&#x3D;%(last_seen_up)s WHERE services.id &#x3D; %(services_id)s]</span><br><span class="line">[parameters: &#123;&#39;last_seen_up&#39;: datetime.datetime(2022, 8, 9, 11, 4, 54, 153870), &#39;services_id&#39;: 7, &#39;updated_at&#39;: datetime.datetime(2022, 8, 9, 11, 4, 54, 256605), &#39;report_count&#39;: 2340897&#125;]</span><br><span class="line">(Background on this error at: http:&#x2F;&#x2F;sqlalche.me&#x2F;e&#x2F;e3q8)</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db Traceback (most recent call last):</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db   File &quot;&#x2F;var&#x2F;lib&#x2F;kolla&#x2F;venv&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;nova&#x2F;servicegroup&#x2F;drivers&#x2F;db.py&quot;, line 92, in _report_state</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db     service.service_ref.save()</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db   File &quot;&#x2F;var&#x2F;lib&#x2F;kolla&#x2F;venv&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;oslo_versionedobjects&#x2F;base.py&quot;, line 226, in wrapper</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db     return fn(self, *args, **kwargs)</span><br><span class="line">2022-08-09 19:05:00.293 67 ERROR nova.servicegroup.drivers.db   File &quot;&#x2F;var&#x2F;lib&#x2F;kolla&#x2F;venv&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;nova&#x2F;objects&#x2F;service.py&quot;, line 406, in save</span><br></pre></td></tr></table></figure><p>2. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;d&lt;/p&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;某天，突然openstack无法创建虚拟机，MQ消息大量堆积&lt;/p&gt;
&lt;h4 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; </summary>
      
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-neutron-常用网络命令</title>
    <link href="https://robin5911.github.io/2022/08/03/openstack-neutron-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>https://robin5911.github.io/2022/08/03/openstack-neutron-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-03T07:28:23.000Z</published>
    <updated>2022-09-09T02:00:50.345Z</updated>
    
    <content type="html"><![CDATA[<p>**创建默认vxlan网络 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron net-create vpc1</span><br></pre></td></tr></table></figure><p>**创建子网 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron subnet-create vpc1-subnet 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure><a id="more"></a><p>**创建 基于vlan 的外部网络, vlan id 199 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron net-create --provider:network_type&#x3D;vlan --provider:segmentation_id&#x3D;199 --router:external&#x3D;true --provider:physical_network&#x3D;physnet1 external-provider</span><br></pre></td></tr></table></figure><p>**创建子网路由器 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron router-create vpc-sub-router</span><br></pre></td></tr></table></figure><p><strong>向路由器添加外部网络。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron router-gateway-set &lt;vpc-sub-router-ID&gt; &lt;external-provider-ID&gt; </span><br></pre></td></tr></table></figure><p><strong>将专用网络添加到路由器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#neutron router-interface-add &lt;vpc-sub-router-ID&gt; &lt;vpc1-subnet-ID&gt;</span><br></pre></td></tr></table></figure><p>**创建浮动ip **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#openstack floating ip create &lt;external-provider-ID&gt; --floating-ip-address &lt;floating-ip-address&gt;</span><br></pre></td></tr></table></figure><h5 id="绑定浮动ip"><a href="#绑定浮动ip" class="headerlink" title="绑定浮动ip"></a>绑定浮动ip</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#openstack server add floating ip  &lt;server-ID&gt; &lt;floating-ip-address&gt; --fixed-ip-address &lt;server-fiexed-ip&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;**创建默认vxlan网络 **&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#neutron net-create vpc1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;**创建子网 **&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#neutron subnet-create vpc1-subnet 192.168.0.0&amp;#x2F;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>openstack-nova-虚拟机热迁移过程源码刨析</title>
    <link href="https://robin5911.github.io/2022/08/01/openstack-nova%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%83%AD%E8%BF%81%E7%A7%BB%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/"/>
    <id>https://robin5911.github.io/2022/08/01/openstack-nova%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%83%AD%E8%BF%81%E7%A7%BB%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/</id>
    <published>2022-08-01T11:10:59.000Z</published>
    <updated>2022-08-05T07:30:53.697Z</updated>
    
    <content type="html"><![CDATA[<p>热迁移主要包括三个阶段：</p><ul><li><strong>pre_live_migration 阶段</strong>：热迁移前的准备阶段，主要在目的计算节点上提前准备虚拟机资源，包括网络资源，例如：建立虚拟机的网卡，然后将网卡加入 OvS br-int 网桥。如果该阶段失败，会有回滚操作。</li><li><strong>内存迁移阶段</strong>：该阶段完全虚拟机虚拟内存数据的迁移，如果虚拟机的系统盘在计算节点本地，那么系统盘数据也会在此时进行迁移。如果该阶段失败，会有回滚操作，回滚流程和 pre_live_migration 阶段一致。</li><li><strong>post_live_migration 阶段</strong>：热迁移完成后资源清理阶段，源计算节点主要是断开源计算节点上虚拟机的卷连接、清理源计算节点虚拟机的网卡资源；目的节点主要是调用 neutronclient，更新 Port Host 属性为目的计算节点。(NOTE：该阶段无需回滚流程，因为虚拟机实际上已经成功迁移，再回滚没有意义）</li></ul><a id="more"></a><p>热迁移流程图如下:</p><p><img src="/images/openstack/nova_live_migrate.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#nova live-migration XXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure><p>当执行虚机热迁移时，请求发给nova-api,  nova中的入口函数是nova/api/openstack/compute 下的migrate_server.py文件中的_migrate_live函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wsgi.action(&#39;os-migrateLive&#39;)</span><br><span class="line">    @validation.schema(migrate_server.migrate_live, &quot;2.0&quot;, &quot;2.24&quot;)</span><br><span class="line">    @validation.schema(migrate_server.migrate_live_v2_25, &quot;2.25&quot;, &quot;2.29&quot;)</span><br><span class="line">    @validation.schema(migrate_server.migrate_live_v2_30, &quot;2.30&quot;, &quot;2.67&quot;)</span><br><span class="line">    @validation.schema(migrate_server.migrate_live_v2_68, &quot;2.68&quot;)</span><br><span class="line">    def _migrate_live(self, req, id, body):</span><br><span class="line">    try:</span><br><span class="line">            self.compute_api.live_migrate(context, instance, block_migration,</span><br><span class="line">                                          disk_over_commit, host, force,</span><br><span class="line">                                          async_)</span><br><span class="line">        ****************                          </span><br></pre></td></tr></table></figure><p>调用到nova/compute/api.py中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@check_instance_lock</span><br><span class="line">    @check_instance_cell</span><br><span class="line">    @check_instance_state(vm_state&#x3D;[vm_states.ACTIVE, vm_states.PAUSED])</span><br><span class="line">    def live_migrate(self, context, instance, block_migration,</span><br><span class="line">                     disk_over_commit, host_name, force&#x3D;None, async_&#x3D;False):</span><br><span class="line">        # 修改虚拟机状态,记录数据库动作</span><br><span class="line">    # 生成request_spec</span><br><span class="line">    # 删除console auth的token信息</span><br><span class="line">    # 检查目标宿主机信息</span><br><span class="line">   try:</span><br><span class="line">            self.compute_task_api.live_migrate_instance(context, instance,</span><br><span class="line">                host_name, block_migration&#x3D;block_migration,</span><br><span class="line">                disk_over_commit&#x3D;disk_over_commit,</span><br><span class="line">                request_spec&#x3D;request_spec, async_&#x3D;async_)  </span><br><span class="line">        ****************    </span><br></pre></td></tr></table></figure><p>live_migrate_instance又调用到了nova/conductor/api.py中的live_migrate_instance函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def live_migrate_instance(self, context, instance, host_name,</span><br><span class="line">                          block_migration, disk_over_commit,</span><br><span class="line">                          request_spec&#x3D;None, async_&#x3D;False):</span><br><span class="line">    scheduler_hint &#x3D; &#123;&#39;host&#39;: host_name&#125;</span><br><span class="line">    if async_:</span><br><span class="line">        self.conductor_compute_rpcapi.live_migrate_instance(</span><br><span class="line">            context, instance, scheduler_hint, block_migration,</span><br><span class="line">            disk_over_commit, request_spec)</span><br><span class="line">    *******************8</span><br></pre></td></tr></table></figure><p>live_migrate_instance又调用到了同级下的nova/conductor/rpcapi.py中的live_migrate_instance函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kw &#x3D; &#123;&#39;instance&#39;: instance, &#39;scheduler_hint&#39;: scheduler_hint,</span><br><span class="line">              &#39;block_migration&#39;: block_migration,</span><br><span class="line">              &#39;disk_over_commit&#39;: disk_over_commit,</span><br><span class="line">              &#39;request_spec&#39;: request_spec,</span><br><span class="line">              &#125;</span><br><span class="line">        version &#x3D; &#39;1.15&#39;</span><br><span class="line">        cctxt &#x3D; self.client.prepare(version&#x3D;version)</span><br><span class="line">        # rpc 广播, 从而交到conductor中处理</span><br><span class="line">        cctxt.cast(context, &#39;live_migrate_instance&#39;, **kw)</span><br></pre></td></tr></table></figure><p>nova/conductor/manager.py 中的live_migrate_instance 收到请求后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@wrap_instance_event(prefix&#x3D;&#39;conductor&#39;)</span><br><span class="line"> def live_migrate_instance(self, context, instance, scheduler_hint,</span><br><span class="line">                           block_migration, disk_over_commit, request_spec):</span><br><span class="line">     self._live_migrate(context, instance, scheduler_hint,</span><br><span class="line">                        block_migration, disk_over_commit, request_spec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">## 初始化一个热迁移任务跟踪对象</span><br><span class="line"> migration &#x3D; objects.Migration(context&#x3D;context.elevated())</span><br><span class="line">        migration.dest_compute &#x3D; destination</span><br><span class="line">        migration.status &#x3D; &#39;accepted&#39;</span><br><span class="line">        migration.instance_uuid &#x3D; instance.uuid</span><br><span class="line">        migration.source_compute &#x3D; instance.host</span><br><span class="line">        migration.migration_type &#x3D; &#39;live-migration&#39;</span><br><span class="line">        if instance.obj_attr_is_set(&#39;flavor&#39;):</span><br><span class="line">            migration.old_instance_type_id &#x3D; instance.flavor.id</span><br><span class="line">            migration.new_instance_type_id &#x3D; instance.flavor.id</span><br><span class="line">        else:</span><br><span class="line">            migration.old_instance_type_id &#x3D; instance.instance_type_id</span><br><span class="line">            migration.new_instance_type_id &#x3D; instance.instance_type_id</span><br><span class="line">        migration.create()</span><br><span class="line"></span><br><span class="line"># 创建热迁移任务,并执行</span><br><span class="line">task &#x3D; self._build_live_migrate_task(context, instance, destination,</span><br><span class="line">                                             block_migration, disk_over_commit,</span><br><span class="line">                                             migration, request_spec)</span><br><span class="line">        try:</span><br><span class="line">            task.execute()</span><br><span class="line">        ***************</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def _build_live_migrate_task(self, context, instance, destination,</span><br><span class="line">                             block_migration, disk_over_commit, migration,</span><br><span class="line">                             request_spec&#x3D;None):</span><br><span class="line">    return live_migrate.LiveMigrationTask(context, instance,</span><br><span class="line">                                          destination, block_migration,</span><br><span class="line">                                          disk_over_commit, migration,</span><br><span class="line">                                          self.compute_rpcapi,</span><br><span class="line">                                          self.servicegroup_api,</span><br><span class="line">                                          self.query_client,</span><br><span class="line">                                          self.report_client,</span><br><span class="line">                                          request_spec)</span><br></pre></td></tr></table></figure><p>代码到了 nova/conductor/tasks/live_migrate.py 下的 _execute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  def _execute(self):</span><br><span class="line">  # 检查云主机是否active状态</span><br><span class="line">      self._check_instance_is_active()</span><br><span class="line">      # 检查源主机宿主机是否有numa topology</span><br><span class="line">      self._check_instance_has_no_numa()</span><br><span class="line">      # 检查源主机宿主机是否可用状态</span><br><span class="line">      self._check_host_is_up(self.source)</span><br><span class="line">#检查源节点，目标节点信息</span><br><span class="line">source_node, dest_node &#x3D; self._check_requested_destination()</span><br><span class="line">  </span><br><span class="line">      return self.compute_rpcapi.live_migration(self.context,</span><br><span class="line">              host&#x3D;self.source,</span><br><span class="line">              instance&#x3D;self.instance,</span><br><span class="line">              dest&#x3D;self.destination,</span><br><span class="line">              block_migration&#x3D;self.block_migration,</span><br><span class="line">              migration&#x3D;self.migration,</span><br><span class="line">              migrate_data&#x3D;self.migrate_data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def _check_requested_destination(self):</span><br><span class="line">       &quot;&quot;&quot;Performs basic pre-live migration checks for the forced host.</span><br><span class="line"></span><br><span class="line">       :returns: tuple of (source ComputeNode, destination ComputeNode)</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">       # 确保源主机和宿主机不是同一物理主机</span><br><span class="line">       self._check_destination_is_not_source()</span><br><span class="line">       # 检查目的主机是否可用</span><br><span class="line">       self._check_host_is_up(self.destination)</span><br><span class="line">       # 检查目的主机是否有足够的内存</span><br><span class="line">       self._check_destination_has_enough_memory()</span><br><span class="line">       # 检查两个源主机和宿主机之间是否兼容</span><br><span class="line">       source_node, dest_node &#x3D; self._check_compatible_with_source_hypervisor(</span><br><span class="line">           self.destination)</span><br><span class="line">       # 检查下是否可以对目的主机执行热迁移操作</span><br><span class="line">       self._call_livem_checks_on_host(self.destination)</span><br><span class="line">       # Make sure the forced destination host is in the same cell that the</span><br><span class="line">       # instance currently lives in.</span><br><span class="line">       # NOTE(mriedem): This can go away if&#x2F;when the forced destination host</span><br><span class="line">       # case calls select_destinations.</span><br><span class="line">       source_cell_mapping &#x3D; self._get_source_cell_mapping()</span><br><span class="line">       dest_cell_mapping &#x3D; self._get_destination_cell_mapping()</span><br><span class="line">       if source_cell_mapping.uuid !&#x3D; dest_cell_mapping.uuid:</span><br><span class="line">           raise exception.MigrationPreCheckError(</span><br><span class="line">               reason&#x3D;(_(&#39;Unable to force live migrate instance %s &#39;</span><br><span class="line">                         &#39;across cells.&#39;) % self.instance.uuid))</span><br><span class="line">       return source_node, dest_node</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中_call_livem_checks_on_host函数会rpc 远程调用到目的主机上去执行/nova/compute/manager.py 下的 check_can_live_migrate_destination函数来检验目的主机是否满足热迁移，同时目的主机也会远程调用check_can_live_migrate_source函数检查源主机是否支持热迁移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">def check_can_live_migrate_destination(self, ctxt, instance,</span><br><span class="line">                                          block_migration, disk_over_commit,</span><br><span class="line">                                          migration&#x3D;None, limits&#x3D;None):</span><br><span class="line">       &quot;&quot;&quot;Check if it is possible to execute live migration.</span><br><span class="line"></span><br><span class="line">       This runs checks on the destination host, and then calls</span><br><span class="line">       back to the source host to check the results.</span><br><span class="line"></span><br><span class="line">       :param context: security context</span><br><span class="line">       :param instance: dict of instance data</span><br><span class="line">       :param block_migration: if true, prepare for block migration</span><br><span class="line">                               if None, calculate it in driver</span><br><span class="line">       :param disk_over_commit: if true, allow disk over commit</span><br><span class="line">                                if None, ignore disk usage checking</span><br><span class="line">       :param migration: objects.Migration object for this live migration.</span><br><span class="line">       :param limits: objects.SchedulerLimits object for this live migration.</span><br><span class="line">       :returns: a LiveMigrateData object (hypervisor-dependent)</span><br><span class="line">       &quot;&quot;&quot;</span><br><span class="line">       src_compute_info &#x3D; obj_base.obj_to_primitive(</span><br><span class="line">           self._get_compute_info(ctxt, instance.host))</span><br><span class="line">       dst_compute_info &#x3D; obj_base.obj_to_primitive(</span><br><span class="line">           self._get_compute_info(ctxt, CONF.host))</span><br><span class="line">       dest_check_data &#x3D; self.driver.check_can_live_migrate_destination(ctxt,</span><br><span class="line">           instance, src_compute_info, dst_compute_info,</span><br><span class="line">           block_migration, disk_over_commit)</span><br><span class="line">       dest_check_data &#x3D; self._dest_can_numa_live_migrate(dest_check_data,</span><br><span class="line">                                                          migration)</span><br><span class="line">       LOG.debug(&#39;destination check data is %s&#39;, dest_check_data)</span><br><span class="line">       try:</span><br><span class="line">           migrate_data &#x3D; self.compute_rpcapi.check_can_live_migrate_source(</span><br><span class="line">               ctxt, instance, dest_check_data)</span><br><span class="line">           LOG.debug(&#39;migrate_data:%s&#39; % migrate_data)</span><br><span class="line">           if (&#39;src_supports_numa_live_migration&#39; in migrate_data and</span><br><span class="line">                   migrate_data.src_supports_numa_live_migration):</span><br><span class="line">               migrate_data &#x3D; self._live_migration_claim(</span><br><span class="line">                   ctxt, instance, migrate_data, migration, limits)</span><br><span class="line">               LOG.debug(&#39;migrate_data:%s&#39; % migrate_data)</span><br><span class="line">           elif &#39;dst_supports_numa_live_migration&#39; in dest_check_data:</span><br><span class="line">               LOG.info(&#39;Destination was ready for NUMA live migration, &#39;</span><br><span class="line">                        &#39;but source is either too old, or is set to an &#39;</span><br><span class="line">                        &#39;older upgrade level.&#39;, instance&#x3D;instance)</span><br><span class="line">           &#39;&#39;&#39;</span><br><span class="line">           # Create migrate_data vifs</span><br><span class="line">           migrate_data.vifs &#x3D; \</span><br><span class="line">               migrate_data_obj.VIFMigrateData.create_skeleton_migrate_vifs(</span><br><span class="line">                   instance.get_network_info())</span><br><span class="line">           # Claim PCI devices for VIFs on destination (if needed)</span><br><span class="line">           port_id_to_pci &#x3D; self._claim_pci_for_instance_vifs(ctxt, instance)</span><br><span class="line">           # Update migrate VIFs with the newly claimed PCI devices</span><br><span class="line">           self._update_migrate_vifs_profile_with_pci(migrate_data.vifs,</span><br><span class="line">                                                      port_id_to_pci)</span><br><span class="line">           &#39;&#39;&#39;</span><br><span class="line">       finally:</span><br><span class="line">           self.driver.cleanup_live_migration_destination_check(ctxt,</span><br><span class="line">                   dest_check_data)</span><br><span class="line">       return migrate_data</span><br></pre></td></tr></table></figure><p>接着便是调用到了nova/compute/rpcapi.py中的live_migration函数，该函数远程调用了nova-compute服务的live_migration方法，交给nova-compute服务来进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def live_migration(self, ctxt, instance, dest, block_migration, host,</span><br><span class="line">                      migration, migrate_data&#x3D;None):</span><br><span class="line">       version &#x3D; &#39;5.0&#39;</span><br><span class="line">       client &#x3D; self.router.client(ctxt)</span><br><span class="line">       cctxt &#x3D; client.prepare(server&#x3D;host, version&#x3D;version)</span><br><span class="line">       cctxt.cast(ctxt, &#39;live_migration&#39;, instance&#x3D;instance,</span><br><span class="line">                  dest&#x3D;dest, block_migration&#x3D;block_migration,</span><br><span class="line">                  migrate_data&#x3D;migrate_data, migration&#x3D;migration)</span><br><span class="line">                  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def live_migration(self, context, dest, instance, block_migration,</span><br><span class="line">                      migration, migrate_data):</span><br><span class="line">       try:</span><br><span class="line">           future &#x3D; self._live_migration_executor.submit(</span><br><span class="line">               self._do_live_migration, context, dest, instance,</span><br><span class="line">               block_migration, migration, migrate_data)</span><br><span class="line">           self._waiting_live_migrations[instance.uuid] &#x3D; (migration, future)</span><br><span class="line">     </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def _do_live_migration(self, context, dest, instance, block_migration,</span><br><span class="line">                           migration, migrate_data):</span><br><span class="line">                          with self.virtapi.wait_for_instance_event(</span><br><span class="line">                    instance, events, deadline&#x3D;deadline,</span><br><span class="line">                    error_callback&#x3D;error_cb):</span><br><span class="line">                with timeutils.StopWatch() as timer:</span><br><span class="line">                    migrate_data &#x3D; self.compute_rpcapi.pre_live_migration(</span><br><span class="line">                        context, instance,</span><br><span class="line">                        block_migration, disk, dest, migrate_data)             </span><br></pre></td></tr></table></figure><p>_do_live_migration函数中的核心代码是pre_live_migration和live_migration的调用。先看self.compute_rpcapi.pre_live_migration函数，其是远程调用到目的主机上执行pre_live_migration函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def pre_live_migration(self, ctxt, instance, block_migration, disk,</span><br><span class="line">        host, migrate_data):</span><br><span class="line">    version &#x3D; &#39;5.0&#39;</span><br><span class="line">    client &#x3D; self.router.client(ctxt)</span><br><span class="line">    cctxt &#x3D; client.prepare(server&#x3D;host, version&#x3D;version,</span><br><span class="line">                           timeout&#x3D;CONF.long_rpc_timeout,</span><br><span class="line">                           call_monitor_timeout&#x3D;CONF.rpc_response_timeout)</span><br><span class="line">    return cctxt.call(ctxt, &#39;pre_live_migration&#39;,</span><br><span class="line">                      instance&#x3D;instance,</span><br><span class="line">                      block_migration&#x3D;block_migration,</span><br><span class="line">                      disk&#x3D;disk, migrate_data&#x3D;migrate_data)</span><br></pre></td></tr></table></figure><p>又回到 compute/manager.py 下的 pre_live_migration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def pre_live_migration(self, context, instance, block_migration, disk,</span><br><span class="line">                           migrate_data):</span><br><span class="line">     bdms &#x3D; objects.BlockDeviceMappingList.get_by_instance_uuid(</span><br><span class="line">            context, instance.uuid)</span><br><span class="line">            </span><br><span class="line">        network_info &#x3D; self.network_api.get_instance_nw_info(context, instance)</span><br><span class="line">        self._notify_about_instance_usage(</span><br><span class="line">            context, instance, &quot;live_migration.pre.start&quot;,</span><br><span class="line">            network_info&#x3D;network_info)</span><br><span class="line">        compute_utils.notify_about_instance_action(</span><br><span class="line">            context, instance, self.host,</span><br><span class="line">            action&#x3D;fields.NotificationAction.LIVE_MIGRATION_PRE,</span><br><span class="line">            phase&#x3D;fields.NotificationPhase.START, bdms&#x3D;bdms)</span><br><span class="line"></span><br><span class="line">        connector &#x3D; self.driver.get_volume_connector(instance)</span><br><span class="line">        try:</span><br><span class="line">            for bdm in bdms:</span><br><span class="line">                if bdm.is_volume and bdm.attachment_id is not None:</span><br><span class="line">                    attach_ref &#x3D; self.volume_api.attachment_create(</span><br><span class="line">                        context, bdm.volume_id, bdm.instance_uuid,</span><br><span class="line">                        connector&#x3D;connector, mountpoint&#x3D;bdm.device_name)</span><br><span class="line">                    migrate_data.old_vol_attachment_ids[bdm.volume_id] &#x3D; \</span><br><span class="line">                        bdm.attachment_id</span><br><span class="line"></span><br><span class="line">                    # update the bdm with the new attachment_id.</span><br><span class="line">                    bdm.attachment_id &#x3D; attach_ref[&#39;id&#39;]</span><br><span class="line">                    bdm.save()</span><br><span class="line"></span><br><span class="line">            block_device_info &#x3D; self._get_instance_block_device_info(</span><br><span class="line">                                context, instance, refresh_conn_info&#x3D;True,</span><br><span class="line">                                bdms&#x3D;bdms)</span><br><span class="line"># 调用libvirt&#x2F;driver.py 做连接上磁盘和挂载上网络的工作等</span><br><span class="line">            migrate_data &#x3D; self.driver.pre_live_migration(context,</span><br><span class="line">                                           instance,</span><br><span class="line">                                           block_device_info,</span><br><span class="line">                                           network_info,</span><br><span class="line">                                           disk,</span><br><span class="line">                                           migrate_data)</span><br><span class="line">            LOG.debug(&#39;driver pre_live_migration data is %s&#39;, migrate_data)</span><br><span class="line">            migrate_data.wait_for_vif_plugged &#x3D; (</span><br><span class="line">                CONF.compute.live_migration_wait_for_vif_plug)</span><br><span class="line"></span><br><span class="line">            # 初始化好网络</span><br><span class="line">            self.network_api.setup_networks_on_host(context, instance,</span><br><span class="line">                                                             self.host)</span><br><span class="line"></span><br><span class="line">            # 在热迁移进行前在目的主机上创建好那些网络过滤规则</span><br><span class="line">            self.driver.ensure_filtering_rules_for_instance(instance,</span><br><span class="line">                                                network_info)</span><br><span class="line">            ****************             </span><br></pre></td></tr></table></figure><p>目标宿主机上调用了 self.driver.pre_live_migration，跳到 libvirt/driver.py下的 pre_live_migration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def pre_live_migration(self, context, instance, block_device_info,</span><br><span class="line">                       network_info, disk_info, migrate_data):</span><br><span class="line">    &quot;&quot;&quot;Preparation live migration.&quot;&quot;&quot;</span><br><span class="line">    ***************************************</span><br><span class="line">    #创建libvirt以及nova相关本地目录，以及根据是否云盘做镜像相关fetch操作</span><br><span class="line">    #连接cinder volume server</span><br><span class="line">    # Establishing connection to volume server.</span><br><span class="line">    block_device_mapping &#x3D; driver.block_device_info_get_mapping(</span><br><span class="line">        block_device_info)</span><br><span class="line"></span><br><span class="line">    if len(block_device_mapping):</span><br><span class="line">        LOG.debug(&#39;Connecting volumes before live migration.&#39;,</span><br><span class="line">                  instance&#x3D;instance)</span><br><span class="line">    #plug vif初始化网卡信息</span><br><span class="line">    self._pre_live_migration_plug_vifs(</span><br><span class="line">        instance, network_info, migrate_data)</span><br></pre></td></tr></table></figure><p>在目的主机上执行完pre_live_migration函数后，源主机上调用live_migration开始执行热迁移操作，z再回看 compute/manager.py 下的 _do_live_migration, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def _do_live_migration(self, context, dest, instance, block_migration,</span><br><span class="line">                           migration, migrate_data):</span><br><span class="line">        try:</span><br><span class="line">            self.driver.live_migration(context, instance, dest,</span><br><span class="line">                                       post_live_migration,</span><br><span class="line">                                       rollback_live_migration,</span><br><span class="line">                                       block_migration, migrate_data)</span><br><span class="line">        except Exception:</span><br><span class="line">            LOG.exception(&#39;Live migration failed.&#39;, instance&#x3D;instance)</span><br><span class="line">            with excutils.save_and_reraise_exception():</span><br><span class="line">                # Put instance and migration into error state,</span><br><span class="line">                # as its almost certainly too late to rollback</span><br><span class="line">                self._set_migration_status(migration, &#39;error&#39;)</span><br><span class="line">                # first refresh instance as it may have got updated by</span><br><span class="line">                # post_live_migration_at_destination</span><br><span class="line">                instance.refresh()</span><br><span class="line">                self._set_instance_obj_error_state(context, instance,</span><br><span class="line">                                                   clean_task_state&#x3D;True)</span><br></pre></td></tr></table></figure><p>调用到nova/virt/libvirt/driver.py中的live_migration函数，再调用到_live_migration函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def live_migration(self, context, instance, dest,</span><br><span class="line">                      post_method, recover_method, block_migration&#x3D;False,</span><br><span class="line">                      migrate_data&#x3D;None):</span><br><span class="line">    #检查目标主机名是否正确,执行迁移               </span><br><span class="line">    self._live_migration(context, instance, dest,</span><br><span class="line">                            post_method, recover_method, block_migration,</span><br><span class="line">                            migrate_data)                  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def _live_migration(self, context, instance, dest, post_method,</span><br><span class="line">                        recover_method, block_migration,</span><br><span class="line">                        migrate_data):</span><br><span class="line">       opthread &#x3D; utils.spawn(self._live_migration_operation,</span><br><span class="line">                                     context, instance, dest,</span><br><span class="line">                                     block_migration,</span><br><span class="line">                                     migrate_data, guest,</span><br><span class="line">                                     device_names)</span><br><span class="line">        try:</span><br><span class="line">            LOG.debug(&quot;Starting monitoring of live migration&quot;,</span><br><span class="line">                      instance&#x3D;instance)</span><br><span class="line">            self._live_migration_monitor(context, instance, guest, dest,</span><br><span class="line">                                         post_method, recover_method,</span><br><span class="line">                                         block_migration, migrate_data,</span><br><span class="line">                                         finish_event, disk_paths)                              </span><br></pre></td></tr></table></figure><p>这里主要有两个核心调用，一个是_live_migration_operation进行迁移操作，一个是调用_live_migration_monitor函数用以监控迁移进度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def _live_migration_operation(self, context, instance, dest,</span><br><span class="line">                                  block_migration, migrate_data, guest,</span><br><span class="line">                                  device_names):</span><br><span class="line">      guest.migrate(self._live_migration_uri(dest),</span><br><span class="line">                          migrate_uri&#x3D;migrate_uri,</span><br><span class="line">                          flags&#x3D;migration_flags,</span><br><span class="line">                          migrate_disks&#x3D;device_names,</span><br><span class="line">                          destination_xml&#x3D;new_xml_str,</span><br><span class="line">                          bandwidth&#x3D;CONF.libvirt.live_migration_bandwidth)</span><br><span class="line">            LOG.debug(&quot;Migrate API has completed&quot;, instance&#x3D;instance)                             </span><br></pre></td></tr></table></figure><p>调用了 guest.py 下的 migrate迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def migrate(self, destination, migrate_uri&#x3D;None, migrate_disks&#x3D;None,</span><br><span class="line">                destination_xml&#x3D;None, flags&#x3D;0, bandwidth&#x3D;0):</span><br><span class="line">      self._domain.migrateToURI3(</span><br><span class="line">            destination, params&#x3D;params, flags&#x3D;flags)           </span><br></pre></td></tr></table></figure><p>_live_migration_monitor的主要实现则是调用了libvirt的job_info函数获取进度情况。</p><p>热迁移过程总结：</p><p>（1）nova-api收到热迁移请求，验证权限、配额等并获取虚拟机信息，通过消息队列向nova-conductor发起热迁移请求</p><p>（2）nova-conductor检查虚拟机是否是开机状态并检查源宿主机计算服务是否正常，然后通过消息队列请求nova-scheduler服务选择目的宿主机</p><p>（3）获取到目的宿主机后，对目的宿主机进行多项是否符合热迁移条件的检查，比如两宿主机的CPU是否兼容、目的宿主机是否可以做热迁移（这里会有个互相检查对方是否可以进行热迁移）等</p><p>（4）nova-conductor通过消息队列服务让目的宿主机执行热迁移工作</p><p>（5）目的宿主机进行网络初始化、网络过滤规则和磁盘准备工作等并通过消息队列让源宿主机执行热迁移操作</p><p>（6）源宿主机调用libvirt的热迁移API进行热迁移操作</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;热迁移主要包括三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pre_live_migration 阶段&lt;/strong&gt;：热迁移前的准备阶段，主要在目的计算节点上提前准备虚拟机资源，包括网络资源，例如：建立虚拟机的网卡，然后将网卡加入 OvS br-int 网桥。如果该阶段失败，会有回滚操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存迁移阶段&lt;/strong&gt;：该阶段完全虚拟机虚拟内存数据的迁移，如果虚拟机的系统盘在计算节点本地，那么系统盘数据也会在此时进行迁移。如果该阶段失败，会有回滚操作，回滚流程和 pre_live_migration 阶段一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;post_live_migration 阶段&lt;/strong&gt;：热迁移完成后资源清理阶段，源计算节点主要是断开源计算节点上虚拟机的卷连接、清理源计算节点虚拟机的网卡资源；目的节点主要是调用 neutronclient，更新 Port Host 属性为目的计算节点。(NOTE：该阶段无需回滚流程，因为虚拟机实际上已经成功迁移，再回滚没有意义）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化-numa架构讲解(1)</title>
    <link href="https://robin5911.github.io/2022/07/28/%E8%99%9A%E6%8B%9F%E5%8C%96-numa%E6%9E%B6%E6%9E%84%E8%AE%B2%E8%A7%A3-1/"/>
    <id>https://robin5911.github.io/2022/07/28/%E8%99%9A%E6%8B%9F%E5%8C%96-numa%E6%9E%B6%E6%9E%84%E8%AE%B2%E8%A7%A3-1/</id>
    <published>2022-07-28T07:43:26.000Z</published>
    <updated>2023-01-28T06:51:08.557Z</updated>
    
    <content type="html"><![CDATA[<p>d</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;d&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="虚拟化" scheme="https://robin5911.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>go-实用方法-判断字符串为uuid类型</title>
    <link href="https://robin5911.github.io/2022/07/27/go-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BAuuid%E7%B1%BB%E5%9E%8B/"/>
    <id>https://robin5911.github.io/2022/07/27/go-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BAuuid%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-07-27T02:41:41.000Z</published>
    <updated>2022-08-05T08:29:47.144Z</updated>
    
    <content type="html"><![CDATA[<p>go 遇到需要判断字符串是否为uuid 类型，函数如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func IsValidUUID(uuid string) bool &#123;</span><br><span class="line">r :&#x3D; regexp.MustCompile(&quot;^[a-fA-F0-9]&#123;8&#125;-[a-fA-F0-9]&#123;4&#125;-4[a-fA-F0-9]&#123;3&#125;-[8|9|aA|bB][a-fA-F0-9]&#123;3&#125;-[a-fA-F0-9]&#123;12&#125;$&quot;)</span><br><span class="line">return r.MatchString(uuid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>推荐使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import github.com&#x2F;robin5911&#x2F;gtools&#x2F;str</span><br><span class="line"></span><br><span class="line">isUuid :&#x3D; str.CheckLikeUUID(&quot;e451f79c-f4ab-4c3a-b895-288bc60c2c5b&quot;)</span><br><span class="line">fmt.Println(isUuid)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;go 遇到需要判断字符串是否为uuid 类型，函数如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func IsValidUUID(uuid string) bool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	r :&amp;#x3D; regexp.MustCompile(&amp;quot;^[a-fA-F0-9]&amp;#123;8&amp;#125;-[a-fA-F0-9]&amp;#123;4&amp;#125;-4[a-fA-F0-9]&amp;#123;3&amp;#125;-[8|9|aA|bB][a-fA-F0-9]&amp;#123;3&amp;#125;-[a-fA-F0-9]&amp;#123;12&amp;#125;$&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return r.MatchString(uuid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="go" scheme="https://robin5911.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-etcd clientv3 包冲突问题</title>
    <link href="https://robin5911.github.io/2022/02/25/go-etcd-clientv3-%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>https://robin5911.github.io/2022/02/25/go-etcd-clientv3-%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-25T09:26:39.000Z</published>
    <updated>2022-07-29T04:15:35.187Z</updated>
    
    <content type="html"><![CDATA[<p>golang 当中操作 etcd 必须 go get go.etcd.io/etcd/clientv3<br>但是会报错如下：</p><h1 id="github-com-coreos-etcd-clientv3-balancer-picker"><a href="#github-com-coreos-etcd-clientv3-balancer-picker" class="headerlink" title="github.com/coreos/etcd/clientv3/balancer/picker"></a>github.com/coreos/etcd/clientv3/balancer/picker</h1><p>F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\picker\err.go:37:44: undefined: balancer.PickOptions<br>F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\picker\roundrobin_balanced.go:55:54: undefined: balancer.PickOptions</p><h1 id="github-com-coreos-etcd-clientv3-balancer-resolver-endpoint"><a href="#github-com-coreos-etcd-clientv3-balancer-resolver-endpoint" class="headerlink" title="github.com/coreos/etcd/clientv3/balancer/resolver/endpoint"></a>github.com/coreos/etcd/clientv3/balancer/resolver/endpoint</h1><p>F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\resolver\endpoint\endpoint.go:114:78: undefined: resolver.BuildOption<br>F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\resolver\endpoint\endpoint.go:182:31: undefined: resolver.ResolveNowOption<br>大概是说原因是 google.golang.org/grpc 1.26 后的版本是不支持 clientv3 的。</p><a id="more"></a><p>也就是说要把这个改成 1.26 版本的就可以了。</p><p>第一种方式：<br>具体操作方法是在 go.mod 里加上：</p><p>replace google.golang.org/grpc =&gt; google.golang.org/grpc v1.26.0<br>或者<br>go mod edit -require=google.golang.org/grpc@v1.26.0<br>如下图所示：</p><p>然后继续 go.etcd.io/etcd/clientv3 看是否还报错！</p><p>如果不行那你就尝试下边的</p><p>第二种方式：<br>更新 grpc 的版本为 1.26.0 版本试试看：</p><p>go get -u -x google.golang.org/grpc@v1.26.0<br>下载完成后将 $GOPATH/pkg/mod/google.golang.org/grpc@v1.26.0 文件重命名为 grpc ，并放到 $GOPATH/src/google.golang.org/grpc 目录下</p><p>=====================================================================</p><p>现在你去编译自己的 go 文件的时候可能会报错：<br>undefined: grpc.SupportPackageIsVersion6 grpc.ClientConnInterface 的问题<br>这是由于 protoc 的 go 语言插件 protoc-gen-go 与 google.golang.org/grpc 版本不兼容所致，<br>因为 grpc 降了到了 v1.26.0，高版本 protoc-gen-go 编译出来的 your-module.pb.go 不兼容低版本的 grpc,<br>所以 protoc-gen-go 也要相应降级。<br>我使用二分法找到 protoc-gen-go 兼容 grpc v1.26.0 的最新版本是 v1.3.2.<br>知道对应版本之后接下来就简单了，运行下面的命令获取该版本并编译二进制文件 GOPATH/bin/protoc-gen-go</p><p>go get github.com/golang/protobuf/protoc-gen-go@v1.3.2<br>重新编译 your.proto 生成 your-module.pb.go 文件，最后重新编译工程你会发现编译错误消失了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang 当中操作 etcd 必须 go get go.etcd.io/etcd/clientv3&lt;br&gt;但是会报错如下：&lt;/p&gt;
&lt;h1 id=&quot;github-com-coreos-etcd-clientv3-balancer-picker&quot;&gt;&lt;a href=&quot;#github-com-coreos-etcd-clientv3-balancer-picker&quot; class=&quot;headerlink&quot; title=&quot;github.com/coreos/etcd/clientv3/balancer/picker&quot;&gt;&lt;/a&gt;github.com/coreos/etcd/clientv3/balancer/picker&lt;/h1&gt;&lt;p&gt;F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\picker\err.go:37:44: undefined: balancer.PickOptions&lt;br&gt;F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\picker\roundrobin_balanced.go:55:54: undefined: balancer.PickOptions&lt;/p&gt;
&lt;h1 id=&quot;github-com-coreos-etcd-clientv3-balancer-resolver-endpoint&quot;&gt;&lt;a href=&quot;#github-com-coreos-etcd-clientv3-balancer-resolver-endpoint&quot; class=&quot;headerlink&quot; title=&quot;github.com/coreos/etcd/clientv3/balancer/resolver/endpoint&quot;&gt;&lt;/a&gt;github.com/coreos/etcd/clientv3/balancer/resolver/endpoint&lt;/h1&gt;&lt;p&gt;F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\resolver\endpoint\endpoint.go:114:78: undefined: resolver.BuildOption&lt;br&gt;F:\Go\pkg\mod\github.com\coreos\etcd@v3.3.22+incompatible\clientv3\balancer\resolver\endpoint\endpoint.go:182:31: undefined: resolver.ResolveNowOption&lt;br&gt;大概是说原因是 google.golang.org/grpc 1.26 后的版本是不支持 clientv3 的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="go" scheme="https://robin5911.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>openstack-基于智能网卡的热迁移实现</title>
    <link href="https://robin5911.github.io/2022/02/16/openstack-%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%BD%91%E5%8D%A1%E7%9A%84%E7%83%AD%E8%BF%81%E7%A7%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>https://robin5911.github.io/2022/02/16/openstack-%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%BD%91%E5%8D%A1%E7%9A%84%E7%83%AD%E8%BF%81%E7%A7%BB%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-02-16T03:09:01.000Z</published>
    <updated>2022-02-16T03:10:10.639Z</updated>
    
    <content type="html"><![CDATA[<p>最近在调研智能网卡，对于使用智能网卡的环境下，如何实现虚拟机的热迁移呢，这里分享一下。</p><p>热迁移的过程分以下几步完成：</p><p>  发起热迁移后，在目的物理机上会启动一个VM，命令参数等同于源物理机上正在运行的VM的启动参数。<br>  标记RAM中所有需要迁移的page为dirty。<br>  发送标记为dirty的page到目的机的VM中，重复多次，直到dirty的page数量减少到某个临界值，或者是达到其他可以触发本阶段结束的条件。<br>  停止源物理机上VM中Guest的运行，并将剩余dirty pages和设备状态发送到目的物理机上的VM中。<br>  目的物理机上VM中Guest开始运行，源物理机上的VM退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在调研智能网卡，对于使用智能网卡的环境下，如何实现虚拟机的热迁移呢，这里分享一下。&lt;/p&gt;
&lt;p&gt;热迁移的过程分以下几步完成：&lt;/p&gt;
&lt;p&gt;  发起热迁移后，在目的物理机上会启动一个VM，命令参数等同于源物理机上正在运行的VM的启动参数。&lt;br&gt;  标记RAM中所有需</summary>
      
    
    
    
    
    <category term="openstack" scheme="https://robin5911.github.io/tags/openstack/"/>
    
  </entry>
  
</feed>
